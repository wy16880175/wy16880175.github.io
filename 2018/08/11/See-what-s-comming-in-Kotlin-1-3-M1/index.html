<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    <meta name="keywords" content="Wooyme, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="Wooyme's Blog" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>See what's comming in Kotlin 1.3-M1 译文 | Wooyme's Blog</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">Wooyme's Blog</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      <div class="logo">
        <img src="/images/ARIA_logo.png" alt="logo">
      </div>
    </div>
    
<nav id="nav" class="nav">
  <a id="nav-toggle" class="nav-toggle"><i class="fas fa-bars"></i></a>
  <ul id="menu">
    
    <li><a href="/">首页</a></li>
    
    <li><a href="/archives/">归档</a></li>
    
    <li><a href="/tags/">标签</a></li>
    
  </ul>
</nav>


  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="post">
  
  <article class="post-container card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://Wooyme.github.io/2018/08/11/See-what-s-comming-in-Kotlin-1-3-M1/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="Wooyme">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="Wooyme's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">See what's comming in Kotlin 1.3-M1 译文</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-08-11T19:41:08+08:00">2018-08-11 19:41:08</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <blockquote>
<p>原文在:<br><a href="https://blog.jetbrains.com/kotlin/2018/07/see-whats-coming-in-kotlin-1-3-m1/" target="_blank" rel="noopener">https://blog.jetbrains.com/kotlin/2018/07/see-whats-coming-in-kotlin-1-3-m1/</a>   </p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天，在一长串的关于Kotlin 1.2.x的更新之后，是时候看看Kotlin 1.3会带来什么。我们很高兴的宣布Kotlin 1.3的尝鲜体验版Kotlin 1.3-M1正式发布。<br>Kotlin 1.3相比之前版本有许多的进步，其中包括 <em>完全体的协程</em>，<em>实验版的无符号类型</em>(Java至今没有的东西),<em>inline class</em> 以及其他更多特性。<br>这里要感谢为我们的新版本贡献代码的社区群众:Raluca Sauciuc, Toshiaki Kameyama, Leonardo Lopes, Jake Wharton, Jeff Wright, Lucas Smaira, Mon_chi, Nico Mandery, Oskar Drozda.  </p>
<blockquote>
<p>完整的ChangeLog<br><a href="https://github.com/JetBrains/kotlin/blob/1.3-M1/ChangeLog.md" target="_blank" rel="noopener">https://github.com/JetBrains/kotlin/blob/1.3-M1/ChangeLog.md</a></p>
</blockquote>
<h1 id="稳定版的协程-1-3之前一直是实验版"><a href="#稳定版的协程-1-3之前一直是实验版" class="headerlink" title="稳定版的协程(1.3之前一直是实验版)"></a>稳定版的协程(1.3之前一直是实验版)</h1><p>终于，在1.3中协程不再是实验性的。无论是语法糖还是标准库都将趋于稳定并且保持向后兼容。自从1.1版本加入协程之后，协程这一特性一直保持着显著的提高。</p>
<blockquote>
<p>几个重要的特性<br>KT-16908 Support callable references to suspending functions<br>KT-18559 Serializability of all coroutine-related classes</p>
</blockquote>
<p>现在，我们简化了协程的核心API，并且去掉了<code>experimental</code>包。同时，我们还在协程的跨平台性中做了许多工作，包括对基于Kotlin/Native（Kotlin的LLVM版本)的IOS支持</p>
<h3 id="转战新协程"><a href="#转战新协程" class="headerlink" title="转战新协程"></a>转战新协程</h3><p>就像我们之前说的一样，所有与协程有关的函数都都已经丢掉了<code>experimental</code>的包名。同时，<code>buildSequence</code>和<code>buildIterator</code>函数也放到了他们在<code>kotlin.sequences</code>包中常驻的地方。<br>在语言的层面上，我们仍然使用<code>suspend</code>关键字来支持协程并且所有的规则几乎与实验版中的规则一致。<br>我们简化了稳定版中的<code>Continuation&lt;T&gt;</code>接口。现在它只保留了 <code>resumeWith(result: SuccessOrFailure&lt;T&gt;)</code>这一个成员函数。原先的<code>resume(value: T)</code>和<code>resumeWithException(exception: Throwable)</code>现在以扩展的形式出现。这个改动只影响了那些少数自己定义协程构造器，那些将回调函数包装成挂起函数(suspending functions)的代码大多数不会发生改变。比如说，为类<code>CompletableFuture&lt;T&gt;</code>定义挂起函数<code>await()</code>还是会像之前一样。<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> CompletableFuture<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T = suspendCoroutine &#123; cont -&gt;<br>    whenComplete &#123; value, exception -&gt;<br>        <span class="hljs-keyword">when</span> &#123;<br>            exception != <span class="hljs-literal">null</span> -&gt; cont.resumeWithException(exception)<br>            <span class="hljs-keyword">else</span> -&gt; cont.resume(value)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>稳定版的协程采用了不同的二进制接口，它们并不能与实验版的协程二进制兼容。为了确保代码能够平稳的转移，我们将在1.3中增加一个兼容层，并且实验版中的类都将保留在标准库中。在Kotlin/JVM中使用Kotlin 1.1-1.2的已经编译好的代码都能在Kotlin 1.3中运行。<br>但是Kotlin 1.3中不提供任何调用1.2(原文中写了1.3，应该是写错了)版本中编译好的实验性协程的支持。如果想要在1.3稳定版协程中使用旧版本协程的库，你需要在1.3版本下重新编译它们。这只是一个暂时的问题，我们会尽快处理。(JetBrains团队的尽快，往往是真的很快)<br>我们还将提供<code>kotlinx.coroutines</code>库的<code>x.x.x-eap13</code>版本。<br>IDE将提示你转移到新的协程上去。我们会在1.3正式版发布前进一步扩大协程的使用范围。</p>
<h1 id="一些新特性"><a href="#一些新特性" class="headerlink" title="一些新特性"></a>一些新特性</h1><p>更重要的特性会出现在实验性部分，这里只提一些为大家带来便利的小特性</p>
<h3 id="捕获when中的参数"><a href="#捕获when中的参数" class="headerlink" title="捕获when中的参数"></a>捕获when中的参数</h3><p>这段懒得翻译了，就看一下代码吧。已经非常明了了<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Request.<span class="hljs-title">getBody</span><span class="hljs-params">()</span></span> =<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> response = executeRequest()) &#123;<br>        <span class="hljs-keyword">is</span> Success -&gt; response.body<br>        <span class="hljs-keyword">is</span> HttpError -&gt; <span class="hljs-keyword">throw</span> HttpException(response.status)<br>    &#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="伴生接口中的-JvmStatic和-JvmField"><a href="#伴生接口中的-JvmStatic和-JvmField" class="headerlink" title="伴生接口中的@JvmStatic和@JvmField"></a>伴生接口中的@JvmStatic和@JvmField</h3><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-meta">@JvmField</span><br>        <span class="hljs-keyword">val</span> ID = <span class="hljs-number">0xF0EF</span><br><br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: Service = ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Kotlin中的接口现在可以把静态成员暴露给Java(捞你Java一手)。</p>
<h3 id="可嵌套的注解声明"><a href="#可嵌套的注解声明" class="headerlink" title="可嵌套的注解声明"></a>可嵌套的注解声明</h3><p>在Kotlin 1.3之前，注解类不能拥有类体(bodies)。1.3版本放宽了这一限制，现在我们允许注解类拥有嵌套类，接口和伴生对象<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span></span>(<span class="hljs-keyword">val</span> param: Inner) &#123;<br>    <span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>(<span class="hljs-keyword">val</span> value: String)<br>&#125;<br><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-meta">@JvmField</span><br>        <span class="hljs-keyword">val</span> timestamp = System.currentTimeMillis()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="函数类型可以有更多参数"><a href="#函数类型可以有更多参数" class="headerlink" title="函数类型可以有更多参数"></a>函数类型可以有更多参数</h3><p>现在一个函数类型，可以拥有超过22个参数了！(Kotlin的一个梗，程序员的暴力美学)。我们现在将上限提高到了JVM的极限——255。如果你想知道我们是怎么做到在不定义额外233个类的情况下实现这个功能的话，请看这里</p>
<blockquote>
<p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/functional-types-with-big-arity-on-jvm.md" target="_blank" rel="noopener">https://github.com/Kotlin/KEEP/blob/master/proposals/functional-types-with-big-arity-on-jvm.md</a></p>
</blockquote>
<h1 id="实验性特性"><a href="#实验性特性" class="headerlink" title="实验性特性"></a>实验性特性</h1><p>就像协程已经证明了的一样，通过把EAP的重要特性设为实验性能帮助我们从社区中收集到可贵的反馈。我们将继续使用这个技术，让Kotlin的所有特性都经过实战的检验。Kotlin 1.3将带来三个激动人心的实验性特性。你需要明确选择使用这些特性，不然编译器会提示警告或者错误。</p>
<h3 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h3><p>内联类能让你在不用真正创建一个类的情况下包装某个类型。<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>(<span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> value: String)<br></code></pre></td></tr></table></figure></p>
<p>当使用这样一个类的时候，编译器会内联它的内容，并且所有操作会直接作用在被包装的类本身。于是，就像下面这样<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> name: Name = Name(<span class="hljs-string">"Mike"</span>)<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">capitalize</span><span class="hljs-params">(name: <span class="hljs-type">Name</span>)</span></span>: Name = Name(name.value.capitalize())<br></code></pre></td></tr></table></figure></p>
<p>编译结果会与下面的代码一样<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> name: String = <span class="hljs-string">"Mike"</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">capitalize</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: String = name.capitalize()<br></code></pre></td></tr></table></figure></p>
<p>内联类与类型别名有些相似，但它们不是赋值兼容的。所以你不能把<code>String</code>赋值给<code>Name</code>,反之亦然。<br>由于内联类实际并不存在，所以不能对它们使用<code>===</code>操作符。<br>还有其他内联类产生包装器的地方，就像<code>Int</code>的装箱一样<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> key: Any = Name(<span class="hljs-string">"Mike"</span>) <span class="hljs-comment">// boxing to actual Name wrapper</span><br><br><span class="hljs-keyword">val</span> pair = Name(<span class="hljs-string">"Mike"</span>) to <span class="hljs-number">27</span> <span class="hljs-comment">// Pair is a generic type, so Name is boxed here too</span><br></code></pre></td></tr></table></figure></p>
<p>这个特性可以通过添加编译选项<code>-XXLanguage:+InlineClasses</code>来开启</p>
<h3 id="无符号数字类型"><a href="#无符号数字类型" class="headerlink" title="无符号数字类型"></a>无符号数字类型</h3><p>内联类最明显的应用就是无符号类型。现在标准库已经加入了<code>UInt</code>，<code>ULong</code>，<code>UByte</code>和<code>UShort</code>。通过内联类，这些类型定义了自己的运算符，可以将存储的数值转化为无符号类型。<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> operand1 = <span class="hljs-number">42</span><br><span class="hljs-keyword">val</span> operand2 = <span class="hljs-number">1000</span> * <span class="hljs-number">100</span>_000<br><br><span class="hljs-keyword">val</span> signed: <span class="hljs-built_in">Int</span> = operand1 * operand2<br><span class="hljs-keyword">val</span> unsigned: UInt = operand1.toUInt() * operand2.toUInt()<br></code></pre></td></tr></table></figure></p>
<p>除了新的类型，我们还添加了一些新的语言特性来让它们变得特殊</p>
<ul>
<li><p>允许在变长参数中使用无符号类型，这与其他内联类不用</p>
<figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">maxOf</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> values: <span class="hljs-type">UInt</span>)</span></span>: UInt &#123; ... &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>无符号类型的关键字</p>
<figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> uintMask = <span class="hljs-number">0xFFFF</span>_FFFFu<br><span class="hljs-keyword">val</span> ulongUpperPartMask = <span class="hljs-number">0xFFFF</span>_FFFF_0000_0000uL<br></code></pre></td></tr></table></figure>
</li>
<li><p>无符号常量</p>
<figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">const <span class="hljs-keyword">val</span> MAX_SIZE = <span class="hljs-number">32768</span>u<br><span class="hljs-comment">//Koltin 1.3-M1暂不支持无符号常量的复杂表达式</span><br>const <span class="hljs-keyword">val</span> MAX_SIZE_BITS = MAX_SIZE * <span class="hljs-number">8</span>u <span class="hljs-comment">// Error in 1.3-M1</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>为了使用无符号类型，你需要选择启动它们</p>
<ul>
<li>either annotate the code element that uses unsigned types with the @UseExperimental(ExperimentalUnsignedTypes::class) annotation</li>
<li>or specify the -Xuse-experimental=kotlin.ExperimentalUnsignedTypes compiler option.</li>
</ul>
<h1 id="新的标准库API"><a href="#新的标准库API" class="headerlink" title="新的标准库API"></a>新的标准库API</h1><p>现在让我们看看1.3中的新API</p>
<h3 id="SuccessOrFailure"><a href="#SuccessOrFailure" class="headerlink" title="SuccessOrFailure"></a>SuccessOrFailure</h3><p>内联类<code>SuccessOrFailure</code>是一个有效的判别函数执行成功或失败<code>Success T | Failure Throwable</code>的集合。它被用来捕获函数的执行结果无论成功或失败，以便于我们在之后的代码中处理它们。<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> files = listOf(File(<span class="hljs-string">"a.txt"</span>), File(<span class="hljs-string">"b.txt"</span>), File(<span class="hljs-string">"42.txt"</span>))<br><span class="hljs-keyword">val</span> contents: List&lt;SuccessOrFailure&lt;String&gt;&gt; = files.map &#123; runCatching &#123; readFileData(it) &#125; &#125;<br><br>println(<span class="hljs-string">"map successful items:"</span>)<br><span class="hljs-keyword">val</span> upperCaseContents: List&lt;SuccessOrFailure&lt;String&gt;&gt; =<br>    contents.map &#123; r -&gt; r.map &#123; it.toUpperCase() &#125; &#125;<br>upperCaseContents.printResults()<br><br>println()<br>println(<span class="hljs-string">"map successful items catching error from transform operation:"</span>)<br><span class="hljs-keyword">val</span> intContents: List&lt;SuccessOrFailure&lt;<span class="hljs-built_in">Int</span>&gt;&gt; =<br>    contents.map &#123; r -&gt; r.mapCatching &#123; it.toInt() &#125; &#125;<br>intContents.printResults()<br></code></pre></td></tr></table></figure></p>
<p>引入这个类最主要的原因是我们想要在新的协程接口中使用<code>resumeWith(result: SuccessOrFailure&lt;T&gt;)</code>而不是<code>resume(T)</code>和<code>resumeWithException(Throwable)</code></p>
<h3 id="多平台随机数生成器"><a href="#多平台随机数生成器" class="headerlink" title="多平台随机数生成器"></a>多平台随机数生成器</h3><p>没啥好说的，原本Kotlin/JVM的东西现在支持Kotlin的所有平台了</p>
<h3 id="Boolean类型的伴生对象"><a href="#Boolean类型的伴生对象" class="headerlink" title="Boolean类型的伴生对象"></a>Boolean类型的伴生对象</h3><p>为Boolean加了个内容为空的伴生对象。今后可能有用，像各种类型比较，转换之类的地方。</p>
<h3 id="基本类型伴生对象的常亮"><a href="#基本类型伴生对象的常亮" class="headerlink" title="基本类型伴生对象的常亮"></a>基本类型伴生对象的常亮</h3><ul>
<li><p>为Byte, Short, Int, Long, Char几个类型加入了SIZE_BITS和SIZE_BYTES</p>
</li>
<li><p>为Char增加了MAX_VALUE(‘\u0000’)和MIN_VALUE(‘\uFFFF’)</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JetBrains的效率是真的挺高。2018年6月发布Kotlin 1.2.50，转眼1个月之后又发布了1.3-M1。1.3版本比较重要的就是协程不再带有实验性标志。同时最有趣的就是内联类了。</p>

    </main>
    <footer class="post-footer">
      
      
      <div class="post-tags">
        
        
        
        
        <a class="post-tag button" href="/tags/Kotlin/" style="background: #fc6423;" rel="tag"><i class="fas fa-tags"></i>Kotlin</a>
        
      </div>
      
    </footer>
  </article>
  
  
<div class="reward" id="reward">
  <p>坚持原创技术分享，您的支持是我前进的动力！</p>
  <button id="reward-button" class="button" disable="enable">打赏</button>
  <div id="qr" class="qr" style="display: none;">
    
    
    
  </div>
</div>


  
  
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
      <a href="/2018/07/30/SQL简单调优-1/" rel="next" title="SQL简单调优(1)"><i class="fas fa-angle-left"></i><span class="nav-title">SQL简单调优(1)</span></a>
      
    </div>
    <div class="post-nav-prev post-nav-item">
      
      <a href="/2018/09/08/Nginx配置fastcgi-perl/" rel="prev" title="Nginx配置fastcgi-perl"><span class="nav-title">Nginx配置fastcgi-perl</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </div>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/sidebar_background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="Wooyme">
  
  <h1 class="author-name">Wooyme</h1>
  <h2 class="author-description"> </h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">11</a></div>
    </div>
    
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="tags-count">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">9</a></div>
    </div>
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    




<hr>
<div class="post-toc sidebar-item" id="toc-div">
  <div><i class="fas fa-list-ol"></i>文章目录</div>
  <div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#稳定版的协程-1-3之前一直是实验版"><span class="toc-text">稳定版的协程(1.3之前一直是实验版)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#转战新协程"><span class="toc-text">转战新协程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一些新特性"><span class="toc-text">一些新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获when中的参数"><span class="toc-text">捕获when中的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伴生接口中的-JvmStatic和-JvmField"><span class="toc-text">伴生接口中的@JvmStatic和@JvmField</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可嵌套的注解声明"><span class="toc-text">可嵌套的注解声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数类型可以有更多参数"><span class="toc-text">函数类型可以有更多参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实验性特性"><span class="toc-text">实验性特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内联类"><span class="toc-text">内联类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无符号数字类型"><span class="toc-text">无符号数字类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#新的标准库API"><span class="toc-text">新的标准库API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SuccessOrFailure"><span class="toc-text">SuccessOrFailure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多平台随机数生成器"><span class="toc-text">多平台随机数生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean类型的伴生对象"><span class="toc-text">Boolean类型的伴生对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型伴生对象的常亮"><span class="toc-text">基本类型伴生对象的常亮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></div>
</div>



    
    
    
<hr>
<div class="social-link sidebar-item">
  <div><i class="far fa-address-card"></i>社交链接</p></div>
  <ul>
    
    <li><i class="fas fa-envelope"></i><a href="mailto:867653608@qq.com" target="_blank">E-Mail</a></li>
    
    <li><i class="fab fa-github"></i><a href="https://github.com/wy16880175" target="_blank">GitHub</a></li>
    
  </ul>
</div>


    
    
    
<hr>
<div class="blogroll sidebar-item">
  <div><i class="fas fa-link"></i>友情链接</div>
  <ul>
    
    <li><a href="http://www.perfectpan.org/" target="_blank">PerfectPan.org</a></li>
    
    <li><a href="https://vertxchina.github.io/vertx-translation-chinese/" target="_blank">Vert.x中文文档</a></li>
    
    <li><a href="https://www.kotlincn.net/" target="_blank">Kotlin中文站</a></li>
    
  </ul>
</div>


    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <a id="back-to-top"><i class="fas fa-angle-double-up"></i></a>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">Wooyme</span><span class="year"><i class="far fa-copyright"></i>2018</span>
        </div>
        
        
<div class="busuanzi">
  <span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv"></span></span>
</div>


        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
