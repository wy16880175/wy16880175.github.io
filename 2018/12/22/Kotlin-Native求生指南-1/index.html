<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    <meta name="keywords" content="Wooyme, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="Wooyme's Blog" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>Kotlin Native求生指南(1) | Wooyme's Blog</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">Wooyme's Blog</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      <div class="logo">
        <img src="/images/ARIA_logo.png" alt="logo">
      </div>
    </div>
    
<nav id="nav" class="nav">
  <a id="nav-toggle" class="nav-toggle"><i class="fas fa-bars"></i></a>
  <ul id="menu">
    
    <li><a href="/">首页</a></li>
    
    <li><a href="/archives/">归档</a></li>
    
    <li><a href="/tags/">标签</a></li>
    
  </ul>
</nav>


  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="post">
  
  <article class="post-container card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://Wooyme.github.io/2018/12/22/Kotlin-Native求生指南-1/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="Wooyme">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="Wooyme's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">Kotlin Native求生指南(1)</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-12-22T00:13:19+08:00">2018-12-22 00:13:19</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><blockquote>
<p><a href="https://github.com/Wooyme/Wsocks-Naitve-Client" target="_blank" rel="noopener">https://github.com/Wooyme/Wsocks-Naitve-Client</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>C++是一门好语言，Go也是一门好语言，Kotlin Native不是。</p>
</blockquote>
<p>首先确定一个观点，写Kotlin-JVM不一定要很懂Java，比如我自己。但是写Kotlin-Native要是不懂C，那就等着吃屎吧。Kotlin Native不是一个让我们跳过C语言走上Native开发道路的神器，至少现在不是。如果你想要Native又不想学C有关的东西的话，选Go吧，我能在这里列举1000个Go的优点和0个缺点。如果一定要说Go有什么缺点的话，那就只能是程序崩溃的时候Go打印的栈信息不能像Java那样漂亮。<br>当然Kotlin Native也不是一无是处，至少它可以督促我再复习一遍C语言的知识。 </p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>现在IDEA和CLION都可以支持Kotlin Native的开发。这个项目我用的是IDEA和Gradle，在开发这个项目之前我也用过CLION和Cmake的组合，要做个比较的话，还是Gradle更加适合我们这些从Kotlin-JVM转过来的玩家，毕竟对于不熟悉Cmake的人来说，看看别人写的CmakeList就已经够头疼的了，更何况要自己写。<br>顺便一提，我是在Ubuntu18.04上开发的。Windows和Linux上开发可能会有比较大的差异，还是推荐Windows上装一下Cygwin，能一定程度上减小这个差异。</p>
<h1 id="第一个工-小-程-坑"><a href="#第一个工-小-程-坑" class="headerlink" title="第一个工(小)程(坑)"></a>第一个工(小)程(坑)</h1><p>从IDEA里创建一个工程是很容易的。不过我遇到了一个小坑，IDEA创完工程之后会出现kt文件打不开的情况，应对的办法是<code>File-&gt;Invalidate Cache/Restart...</code><br>从这第一个坑开始，我们就踏上了Kotlin Native的漫漫坑爹路。工程创建之后会有一个默认的文件，里面是个hello world，我们编译运行一下。编译这个过程只能从Gradle里执行，在<code>other</code>里<code>runProgram</code>，顺利的话Hello World就就会成功打印出来。这里应该不会遇到什么问题，Gradle会智能的下载KN的编译器，只是可能会有点慢。</p>
<h2 id="我能干什么"><a href="#我能干什么" class="headerlink" title="我能干什么"></a>我能干什么</h2><p>爬过第一个坑之后，你可能迫不及待的想写点什么，比如来一个文件IO，你可能会习惯性的写一个<code>File</code>然后等待IDEA的语法提示，但是令人失望的是，IDEA除了把你的<code>File</code>标记为红色以外什么都不会做。然后你也许还会试一试其他你在JVM里经常用的类，但是它们多半没有，除了<code>StringBuilder</code>这个SB，它还是依然坚挺。<br>这个时候你可能才意识到，大清亡了，世界变了，原来的那些小伙伴都不在了。剩下的只有少的可怜的<em>Kotlin标准库</em>和陌生的<em>stdlib</em>、<em>posix</em>、<em>win32</em>或者<em>linux</em>、<em>darwin</em>以及我至今不能理解为什么要放在默认支持库里的<em>zlib</em>(我觉得唯一的可能就是JetBrains的人想试试cinterop好不好用)。</p>
<h2 id="认清现实"><a href="#认清现实" class="headerlink" title="认清现实"></a>认清现实</h2><p>好了，既然之前的都用不了了，那就不得不重新开始。让我们来看一看Kotlin Native的文件操作应该是什么样的。<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">//读取一个完整的文件，保存到String中</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> fp = fopen(myHome+<span class="hljs-string">"save.json"</span>, <span class="hljs-string">"r"</span>) ?: <span class="hljs-keyword">return</span> println(<span class="hljs-string">"Cannot open"</span>)<br>    <span class="hljs-keyword">val</span> fileStat = nativeHeap.alloc&lt;stat&gt;()<br>    stat(myHome+<span class="hljs-string">"save.json"</span>,fileStat.ptr)<br>    <span class="hljs-keyword">val</span> size = fileStat.st_size.toInt()+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">val</span> bytes = nativeHeap.allocArray&lt;ByteVar&gt;(size)<br>    fread(bytes,size.toULong(),size.toULong(),fp)<br>    <span class="hljs-keyword">val</span> text = bytes.toKString()<br>    nativeHeap.free(fileStat.ptr)<br>    fclose(fp)<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>OK,先说明一下，官方的例程里很少使用nativeHeap，它们比较喜欢用memScope{}，这两个的区别我会在之后说明。现在先让我们看完这段代码。相信如果你还记得C语言的东西的话，你肯定会说:”这tm不就是C吗”。没错，这tm就是Kotlin版C语言。Old fashion的<code>fopen</code>，<code>stat</code>，<code>fread</code>，当然这一切都无可厚非，毕竟Native的世界和Java的世界本来就大相径庭。我们也可以自己动手封装一个File类出来，我也相信Jetbrains会在某一个版本把这些基本的工具加入到Kotlin Native的标准库中去的。<br>除开C的部分，还是有些东西值得我们关注的，比如刚刚说的<code>nativeHeap</code>，以及一个有趣的方法——<code>toKString()</code>。这个方法真的可以说是Kotlin Native最后的仁慈了。我们知道Kotlin的String和C的const char<em> 是两个完全不同的体系。String类里有记录String长度的部分，好让我们知道String在什么位置结束，但是const char</em> 不同，它依赖结尾处的<code>0x00</code>来判断字符串是否结束。于是这里Kotlin Native很<strong>贴心</strong>的为我们加入了<code>toKString()</code>和<code>String.cstr</code>来保证两者间的转换。</p>
<h1 id="nativeHeap和memScope？"><a href="#nativeHeap和memScope？" class="headerlink" title="nativeHeap和memScope？"></a>nativeHeap和memScope？</h1><blockquote>
<p>参考资料 <a href="https://resources.jetbrains.com/storage/products/kotlinconf2018/slides/5_Kotlin-Native%20concurrency%20and%20memory%20model%20(1).pdf" target="_blank" rel="noopener">https://resources.jetbrains.com/storage/products/kotlinconf2018/slides/5_Kotlin-Native%20concurrency%20and%20memory%20model%20(1).pdf</a></p>
</blockquote>
<p>有一点是我们必须要知道的，那就是Kotlin Native是有GC的。在Kotlin自己的世界里，GC是隐藏在代码之下的，就像java一样，它们用引用计数法(<em>Simple local reference-counter based algorithm</em>)、”试图删除法”(<em>Cycle collector based on the trial deletion</em>)等算法保证GC的工作。但是由于Kotlin Native提供的东西实在是太少了，我们不得不依赖很多<em>C library</em>,于是手动分配内存就成了不可避免的事情。<br>手动内存管理是场噩梦，这个道理让最顽固的C++也被迫妥协，从析构到现在的智能指针，C++可以说是做了许多让步了。毫无疑问，Kotlin也是懂这个道理的。于是JetBrains推出了memScope这个东西。</p>
<h2 id="memScope"><a href="#memScope" class="headerlink" title="memScope"></a>memScope</h2><p>memScope的作用是当memScope的作用域结束的时候，自动释放在里面分配的所有内存，以刚才的例子来说<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> bytes = nativeHeap.allocArray&lt;ByteVar&gt;(size)<br></code></pre></td></tr></table></figure></p>
<p>应该写成<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> text = memScope&#123;<br>    <span class="hljs-keyword">val</span> bytes = nativeHeap.allocArray&lt;ByteVar&gt;(size)<br>    fread(bytes,size.toULong(),size.toULong(),fp)<br>    bytes.toKString()<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这样当memScope结束的时候，bytes就被自动释放了，而text则是通过<code>toKString()</code>方法实例化的一个String类，可以被KN自己的GC机制回收。所以这段代码不会导致任何内存泄露。除此之外还有很多方法是需要在memScope中才能执行的，比如说<code>CValues&lt;T&gt;.ptr</code>这是用来获取CValues的指针，关于这个稍微说一下我的看法,ptr的getter应该是<em>重新分配</em>了一块内存，然后把CValues中的值<em>复制</em>了进去，因此才需要在memScope中执行，以保证内存不会泄露，不过这又导致了一个新的坑，我在之后会提到。</p>
<h2 id="nativeHeap"><a href="#nativeHeap" class="headerlink" title="nativeHeap"></a>nativeHeap</h2><p>那为什么我们还需要nativeHeap这样的方式来分配内存呢。还是举个例子吧。<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> mgr = nativeHeap.alloc&lt;mg_mgr&gt;().ptr<br>    mg_mgr_init(mgr, <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">while</span> (flag) &#123;<br>        mg_mgr_poll(_mgr, <span class="hljs-number">100</span>)<br>    &#125;<br>    mg_mgr_free(mgr)<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>mg是一个C的网络库，我们启动了一个事件循环来处理各种网络请求。可以看到，这个库自带了一个释放函数<code>mg_mgr_free</code>,被<code>mg_mgr_init</code>初始化过的内存应该由这个库本身来释放。如果我们把代码写成下面这样<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    memScope&#123;<br>        <span class="hljs-keyword">val</span> mgr = alloc&lt;mg_mgr&gt;().ptr<br>        mg_mgr_init(mgr, <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">while</span> (flag) &#123;<br>            mg_mgr_poll(_mgr, <span class="hljs-number">100</span>)<br>        &#125;<br>        mg_mgr_free(mgr)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>那么在循环终止，程序运行完<code>mg_mgr_free</code>之后很有可能就会因为<code>double free</code>而<em>崩溃</em>。其实我也不是很理解为什么一块内存不能释放两次，或者应该说free为什么不能对同一块内存执行两次，就算已经释放了，给我返回个false也好，何必搞个崩溃呢。总之这也算是刚开始写KN时很容易遇到的一个坑。</p>
<h2 id="内存管理导致的坑"><a href="#内存管理导致的坑" class="headerlink" title="内存管理导致的坑"></a>内存管理导致的坑</h2><p>在我的工程里，遇到了这么个情况。我有一个系统托盘的功能，里面有一些菜单元素也就是Item，这些Item都是要显示一些字，图标之类的，当然还有回调，每次菜单变化的时候都需要调用一个<code>update</code>函数，这个函数的执行过程实际上就是重新初始化一个整个菜单。<br>最初我的代码是这样的<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> tray = nativeHeap.alloc&lt;tray&gt;()<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//设成2是因为tray的C实现需要以空为结尾</span><br>    <span class="hljs-keyword">val</span> menus = nativeHeap.allocArray&lt;tray_menu&gt;(<span class="hljs-number">2</span>)<br>    memScope&#123;<br>        menus[<span class="hljs-number">0</span>].text = <span class="hljs-string">"设置"</span>.cstr.ptr<br>        <span class="hljs-comment">//staticCFunction看名字就能知道是为了提供C语言中的"函数指针"</span><br>        menus[<span class="hljs-number">0</span>].cb = staticCFunction &#123; _ -&gt;<br>            <span class="hljs-comment">//balabalabalabala</span><br>            tray_update(tray.ptr)<br>        &#125;<br>        tray.menu = menus<br>        tray_init(tray.ptr)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>代码看上去没什么问题，启动的时候也没什么问题，但是当运行<code>menus[0]</code>的<code>callback</code>执行的时候问题就来了。update之后”设置“这两个字变成了乱码，而罪魁祸首就是memScope。memScope在作用域结束的时候释放掉了<code>&quot;设置&quot;.cstr.ptr</code>这个指针(ptr)对应的内存，也就是说在<code>tray_init</code>之后<code>menus[0].text</code>已经是个野指针了。于是当我们执行<code>tray_update</code>的时候，这块内存会是什么样子已经不是我们能够控制的了。于是，我被迫写出了这样的代码<br><figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> tray = nativeHeap.alloc&lt;tray&gt;()<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//设成2是因为tray的C实现需要以空为结尾</span><br>    <span class="hljs-keyword">val</span> menus = nativeHeap.allocArray&lt;tray_menu&gt;(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">val</span> text = <span class="hljs-string">"设置"</span>.cstr<br>    <span class="hljs-keyword">val</span> textPtr = nativeHeap.allocArray&lt;ByteVar&gt;(text.size)<br>    memScope&#123;<br>        <span class="hljs-comment">//把内存复制到不会被自动释放的地方</span><br>        memcpy(textPtr,text.ptr,text.size.toULong())<br>    &#125;<br>    menus[<span class="hljs-number">0</span>].text = textPtr<br>    menus[<span class="hljs-number">0</span>].cb = staticCFunction &#123; _ -&gt;<br>            <span class="hljs-comment">//balabalabalabala</span><br>            tray_update(tray.ptr)<br>        &#125;<br>        tray.menu = menus<br>        tray_init(tray.ptr)<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>这只能说是很傻逼了,可能KN提供了一些更加优雅的方式只是我不知道。但总之Kotlin Native的<code>memScope</code>在某些情况下是会与C产生冲突的，而且这种问题往往很隐蔽，这也就是为什么野指针会成为困扰C/C++这么久的问题。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>OK，去掉代码大概有3000个字了。<br>第一篇就先到此为止，大概写了一下我对Kotlin Native的看法和对它内存模型的认识以及使用中遇到的几个坑。下一篇会应该会写一下Cinterop，和Kotlin Native的多线程模型。KN的多线程对于初学者来说也是个神坑，就没见过这样的线程模型，而且文档也比较含糊，不过毕竟还在频繁更新，很多东西变的太快了，文档也确实比较难写。</p>

    </main>
    <footer class="post-footer">
      
      
      <div class="post-tags">
        
        
        
        
        <a class="post-tag button" href="/tags/Kotlin/" style="background: #fc6423;" rel="tag"><i class="fas fa-tags"></i>Kotlin</a>
        
        <a class="post-tag button" href="/tags/Native/" style="background: #a3bb54;" rel="tag"><i class="fas fa-tags"></i>Native</a>
        
        <a class="post-tag button" href="/tags/C/" style="background: #47aaff;" rel="tag"><i class="fas fa-tags"></i>C</a>
        
      </div>
      
    </footer>
  </article>
  
  
<div class="reward" id="reward">
  <p>坚持原创技术分享，您的支持是我前进的动力！</p>
  <button id="reward-button" class="button" disable="enable">打赏</button>
  <div id="qr" class="qr" style="display: none;">
    
    
    
  </div>
</div>


  
  
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
      <a href="/2018/12/16/自己动手写Ss/" rel="next" title="自己动手写Ss"><i class="fas fa-angle-left"></i><span class="nav-title">自己动手写Ss</span></a>
      
    </div>
    <div class="post-nav-prev post-nav-item">
      
      <a href="/2018/12/22/Kotlin-Native求生指南-2/" rel="prev" title="Kotlin Native求生指南(2)"><span class="nav-title">Kotlin Native求生指南(2)</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </div>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/sidebar_background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="Wooyme">
  
  <h1 class="author-name">Wooyme</h1>
  <h2 class="author-description"> </h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">14</a></div>
    </div>
    
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="tags-count">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">12</a></div>
    </div>
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    




<hr>
<div class="post-toc sidebar-item" id="toc-div">
  <div><i class="fas fa-list-ol"></i>文章目录</div>
  <div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#项目地址"><span class="toc-text">项目地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发环境"><span class="toc-text">开发环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个工-小-程-坑"><span class="toc-text">第一个工(小)程(坑)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#我能干什么"><span class="toc-text">我能干什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#认清现实"><span class="toc-text">认清现实</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nativeHeap和memScope？"><span class="toc-text">nativeHeap和memScope？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#memScope"><span class="toc-text">memScope</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nativeHeap"><span class="toc-text">nativeHeap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理导致的坑"><span class="toc-text">内存管理导致的坑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></div>
</div>



    
    
    
<hr>
<div class="social-link sidebar-item">
  <div><i class="far fa-address-card"></i>社交链接</p></div>
  <ul>
    
    <li><i class="fas fa-envelope"></i><a href="mailto:867653608@qq.com" target="_blank">E-Mail</a></li>
    
    <li><i class="fab fa-github"></i><a href="https://github.com/wy16880175" target="_blank">GitHub</a></li>
    
  </ul>
</div>


    
    
    
<hr>
<div class="blogroll sidebar-item">
  <div><i class="fas fa-link"></i>友情链接</div>
  <ul>
    
    <li><a href="http://www.perfectpan.org/" target="_blank">PerfectPan.org</a></li>
    
    <li><a href="https://vertxchina.github.io/vertx-translation-chinese/" target="_blank">Vert.x中文文档</a></li>
    
    <li><a href="https://www.kotlincn.net/" target="_blank">Kotlin中文站</a></li>
    
  </ul>
</div>


    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <a id="back-to-top"><i class="fas fa-angle-double-up"></i></a>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">Wooyme</span><span class="year"><i class="far fa-copyright"></i>2018</span>
        </div>
        
        
<div class="busuanzi">
  <span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv"></span></span>
</div>


        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
