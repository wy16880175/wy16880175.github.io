<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wooyme&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wooyme.github.io/"/>
  <updated>2020-03-16T12:31:26.169Z</updated>
  <id>http://wooyme.github.io/</id>
  
  <author>
    <name>Wooyme</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wooyme教你秽土转生(2)</title>
    <link href="http://wooyme.github.io/2020/03/16/Wooyme%E6%95%99%E4%BD%A0%E7%A7%BD%E5%9C%9F%E8%BD%AC%E7%94%9F-2/"/>
    <id>http://wooyme.github.io/2020/03/16/Wooyme教你秽土转生-2/</id>
    <published>2020-03-16T11:50:48.000Z</published>
    <updated>2020-03-16T12:31:26.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇讲了如何秽土转生，但是有个问题，Memcached在电信下效果极差。所以在经过不少搜索之后我看中了另一个缓存数据库——<strong>Redis</strong>。选择Redis就会出现另一个问题，Redis的安全配置并不像Memcached那么弱智。全球虽然也有非常多的Redis服务器，但是大部分还是需要验证或是没有anonymous的写入权限。</p><p>所以这就需要我们找出那些真正可用的Redis服务器。</p><h1 id="ZoomEye"><a href="#ZoomEye" class="headerlink" title="ZoomEye"></a>ZoomEye</h1><p>我在前篇也提到了<strong>ZoomEye</strong>，根据ZoomEye的数据显示，全球有超过50万台Memcached服务器。那么什么是ZoomEye呢？ ZoomEye是一家网络安全的搜索引擎，通过后台运行的庞大扫描程序扫描整个互联网，并记录各个IP开放的各种端口。</p><blockquote><p><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a></p></blockquote><p>搜索Redis比较好用的关键字是</p><blockquote><p>cluster +app:redis +subdivisions:”香港”</p></blockquote><p>后面两个分别是限制应用和地区，第一个<code>cluster</code>算是个小技巧。因为ZoomEye的扫描器在连接到Redis后会运行info命令，如果Redis没有权限验证，那么在返回的结果里就会有<code>cluster</code>。所以在搜索的时候加上<code>cluster</code>可以让ZoomEye只返回没有权限验证的结果。</p><h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><p>网页搜索不好整理结果，所以有大牛做了cli的版本</p><blockquote><p><a href="https://github.com/gelim/zoomeye" target="_blank" rel="noopener">https://github.com/gelim/zoomeye</a></p><p>python zoomeye.py -l 记录数 –user 用户名 –password 密码 “cluster +app:redis +subdivisions:香港”</p></blockquote><h1 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h1><p>在拿到了无需登录即可执行命令的Redis服务器列表之后还需要判断服务器是否有匿名读写的权限。这个时候就要看Nmap了。</p><h2 id="Nmap-Script"><a href="#Nmap-Script" class="headerlink" title="Nmap Script"></a>Nmap Script</h2><p>我写了个Nmap的脚本用于检测是否可以写</p><pre><code class="lua">local brute = require &quot;brute&quot;local creds = require &quot;creds&quot;local redis = require &quot;redis&quot;local shortport = require &quot;shortport&quot;local stdnse = require &quot;stdnse&quot;description = [[Performs brute force passwords auditing against a Redis key-value store.]]----- @usage-- nmap -p 6379 &lt;ip&gt; --script redis-brute---- @output-- PORT     STATE SERVICE-- 6379/tcp open  unknown-- | redis-brute:-- |   Accounts-- |     toledo - Valid credentials-- |   Statistics-- |_    Performed 5000 guesses in 3 seconds, average tps: 1666----author = &quot;Wooyme&quot;license = &quot;Same as Nmap--See https://nmap.org/book/man-legal.html&quot;categories = {&quot;intrusive&quot;, &quot;brute&quot;}portrule = shortport.port_or_service(6379, &quot;redis&quot;)local function checkRedis(host, port)  local helper = redis.Helper:new(host, port)  local status = helper:connect()  if( not(status) ) then    return false, &quot;Failed to connect to server&quot;  end  local status, response = helper:reqCmd(&quot;SET&quot;, &quot;thisisaredistest&quot;,&quot;thisisaredistest&quot;)  if ( not(status) ) then    return false, &quot;Failed to request SET command&quot;  end  if ( redis.Response.Type.ERROR == response.type ) then    if ( &quot;-ERR operation not permitted&quot; == response.data ) or        ( &quot;-NOAUTH Authentication required.&quot; == response.data) then      return false, &quot;Need Authentication&quot;    end  end  return true, hostendaction = function(host, port)  local status, msg =  checkRedis(host, port)  return msgend</code></pre><p>脚本是用redis-brute改的。</p><blockquote><p>nmap -Pn -sT -p 6379 -iL iplist.txt –script=redis-brute.nse | grep -oE “ip: \b([0-9]{1,3}.){3}[0-9]{1,3}\b” | grep -oE “\b([0-9]{1,3}.){3}[0-9]{1,3}\b”</p></blockquote><p>使用这样的命令就可以整理出最后的可用ip列表。</p><p>扫描了一下香港400个无需权限的结果里有200个左右的匿名可写。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实世界还上有不需要鉴权还能匿名读写的Redis服务器我觉得也是挺夸张的了，而且不少是IDC的，无语。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇讲了如何秽土转生，但是有个问题，Memcached在电信下效果极差。所以在经过不少搜索之后我看中了另一个缓存数据库——&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="Hacker" scheme="http://wooyme.github.io/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>Wooyme教你如何秽土转生</title>
    <link href="http://wooyme.github.io/2020/03/04/Wooyme%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%A7%BD%E5%9C%9F%E8%BD%AC%E7%94%9F/"/>
    <id>http://wooyme.github.io/2020/03/04/Wooyme教你如何秽土转生/</id>
    <published>2020-03-03T19:27:24.000Z</published>
    <updated>2020-03-04T09:09:11.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>租廉价VPS的时候经常会遇到一个问题，租到的这个IP已经被封了或者这个机房的线路烂的连魔改版bbr都救不了。这个时候我们就基本上只能任命，或者再roll一次，或者就放弃这个家了。<br>那么，就真的没有办法了吗？</p><h1 id="灵感来源：DDOS"><a href="#灵感来源：DDOS" class="headerlink" title="灵感来源：DDOS"></a>灵感来源：DDOS</h1><p>没错，就是DDOS，毕竟我也是做安全出身的。DDOS里有一种很独特的攻击方式叫做放大型DDOS，有时候也叫反射型DDOS。这种攻击的方式首先要寻找那些开放udp端口，并且你给它发包它能返回你一个更大的包的服务器，找到一批这样的服务器之后，就可以伪造成被攻击对象的ip像服务器发包，然后服务器就会把这个更大的返回包发向被攻击的机器。以此来实现<strong>放大</strong>。</p><p>那放大型DDOS和我们想要的“秽土转生术”有什么关系呢。你品、你细品。想要让一台机器复活，我们就要为它找一个中间人。如果能够让墙内的机器通过中间人与我们的服务器通信，那不就等于复活了我们的服务器。而放大型DDOS多多少少有些这样的特质，所以我寻找了很多关于放大型DDOS的资料，终于让我找到了一个最接近的方案。</p><h1 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h1><blockquote><p><a href="https://paper.seebug.org/898/#37memcached" target="_blank" rel="noopener">https://paper.seebug.org/898/#37memcached</a></p></blockquote><p>一切源于seebug的这篇文章。</p><blockquote><p>Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。Memcached是以LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的一款软件。现在已成为mixi、hatena、Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。Memcached简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的API兼容大部分流行的开发语言。本质上，它是一个简洁的key-value存储系统。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。</p></blockquote><p>最关键的是</p><blockquote><p>Memcached Server在默认情况下同时开启了TCP/UDP 11211端口，并且无需认证既可使用Memcached的储存服务</p></blockquote><p><strong>无需认证既可使用</strong>，这太离谱了。</p><p>然后我又在<em>ZoomEye</em>上搜索了一下，全球有超过50万台机器开放着11211端口。这不就直接无限剑制了吗。</p><p>当然我后来又查到在某个更新里Memcached把默认的udp端口给取消了，也就是说现在的Memcached服务端大部分是只开了tcp端口的，毕竟再这样下去Memcached都快成为反射型DDOS的老大了。但是这个并不是问题，毕竟我们的目的不是DDOS，这个<strong>无需认证既可使用</strong>真的太香了。</p><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>所以现在的问题只有一个，客户端和服务端如何通过Memcached中间人进行通信。这种通信方式明显会与常规的通信方式有很大的差别。<em>这就像两个间谍，确定了要在某个地点交换情报，但是这两个人又不能见面，所以只能把情报放在一个角落里，等对方过段时间来拿。</em></p><p>下面看一下如何实现这样的一种通信。首先既然Memcached存储的是键值对，那么如何设计这个键就是我们要解决的第一个问题。</p><pre><code class="Java">id + flagPair.first + Integer.toHexString(offsetRead)</code></pre><p>上面这个就是我设计的键。由于我最终想要达到类似长连接的效果，所以引入了<code>id</code>来作为每个连接的标识符，然后<code>flagPair</code>是一个包含<code>&quot;s&quot;</code>和<code>&quot;c&quot;</code>的<code>Pair</code>，以此来区分客户端和服务端，最后的<code>offsetRead</code>比较复杂，后面会详细说明。</p><p>那么有了这个<code>key</code>之后，服务端与客户端就可以通过读取和写入Memcached来通信了。</p><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p><code>id</code>和<code>flagPair</code>都是用来确定这个连接的，而<code>offsetRead</code>才是读取写入的关键。首先可以想到，有<code>offsetRead</code>那肯定也有<code>offsetWrite</code>。我规定每次写入都会使<code>offsetWrite</code>+1，同样的，每次成功的读取也会使<code>offsetRead</code>+1。那为什么要有<code>offset</code>呢？理论上说如果没有<code>offset</code>，连接双方永远在同一个键下读取写入也是完全可以的，但这种理论的前提是网络延迟要低于我们轮询的时间间隔，并且写入速度要小于读取速度。如果这两个条件不成立的话，就会出现后面的值覆盖先前的值，继而导致丢包。</p><p>所以为了在真实的网络情况下获得较好的性能，我们要在Memcached中建立一个缓冲区，而这个<code>offset</code>就成了表示缓冲区中各个数据位置的标志。</p><h2 id="快速读取"><a href="#快速读取" class="headerlink" title="快速读取"></a>快速读取</h2><p>在规定了<code>offset</code>之后，如何高效的读取依然是个问题。因为读取的时候是无法知道在这段时间里缓冲区中有多少条数据的。如果每一轮只读一个，那整体的带宽必然会受到很大限制。所以我加入了一种类似窗口的机制。</p><p>在初始状态下，每50ms发送4次<code>GET</code>请求.这里当然还有另外一个问题，由于延迟的存在，发送请求之后并不能立马得到返回，即使是使用香港的Memcached服务器做中继，延迟也普遍在100ms以上。所以如果我们等待请求返回后再发送下一轮请求的话，两次请求的间隔就可能是150ms了。</p><p>因此我采用了一种乐观的策略，即<strong>认为Memcached中永远有数据</strong>。即使前面的请求还没有返回，我们也假设前面的请求能成功获取数据，并且使<code>offsetRead</code>增加，所以每到50ms我们就会发送一轮新的请求。等到前面的请求返回了，如果返回为空，则重置<code>offsetRead</code>，如果有返回则不改动<code>offsetRead</code>，以此来保证降低延迟。</p><p>但是接着我们就会发现，如果每个数据最大是1kb，即使每个数据都达到最大值，且每个请求都能成功返回，那我们的带宽也只有<code>1000/50*4=80kb</code>。所以我们需要动态的修改<code>4</code>这个数字。在这里我引入了这样一种逻辑，如果每次发送的4个请求全部有数据返回，则认为后面还有更多的数据要返回。所以每当4个请求全部成功返回的时候，我们就加倍，使下一轮一次性发送8个请求，后续同理。直到达到我们设定的上限。这样假如上限是64，那峰值带宽就可以达到<code>1000/50*64=1280kb</code>的速度。而当我们的请求有半数以上返回空值的时候就直接重置这个窗口。</p><p>在加载视频或是下载的时候，通过这种逻辑往往可以得到比较好的效果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过Memcached中继可以隐藏真正的服务器，我也在自己的Wsocks中加入了这样功能。不过在实际使用中也发现一些问题。第一、如果延迟过高，那么上述的逻辑中窗口爬升的速度会非常慢，整体网速也就很烂，所以比较推荐使用日本、香港这样的Memcached服务器。第二、电信网的表现非常差，可能因为Memcached与DDOS有关，导致来自11211端口的流量被电信屏蔽，这一点暂时无法解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;租廉价VPS的时候经常会遇到一个问题，租到的这个IP已经被封了或者这个机房的线路烂的连魔改版bbr都救不了。这个时候我们就基本上只能任命，或
      
    
    </summary>
    
    
      <category term="网络" scheme="http://wooyme.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JVM那些我们不知道的参数</title>
    <link href="http://wooyme.github.io/2020/01/20/JVM%E9%82%A3%E4%BA%9B%E6%88%91%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>http://wooyme.github.io/2020/01/20/JVM那些我们不知道的参数/</id>
    <published>2020-01-20T13:37:42.000Z</published>
    <updated>2020-01-22T12:35:55.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还是我的Wsocks(不过现在改名SuperEngine了)，在兜兜转转了许久之后还是回到了最初的起点。要什么Kotlin Native，要什么Go，要什么GraalVm，都是垃圾，原始的才是最好的。</p><h1 id="客户端之痛"><a href="#客户端之痛" class="headerlink" title="客户端之痛"></a>客户端之痛</h1><p>JVM的客户端为什么那么少？ 我们往往能看到 .net系列，C++甚至是go的客户端但是为什么没有java的客户。个人觉得原因主要在启动速度慢和内存占用高这两个地方。对于服务端来说JVM的启动时间可以忽略不计，而默认的内存策略也不会有太多问题，但是客户端上大家都想要小巧玲珑的类型，JVM就有些不合适了。</p><h1 id="JVM内存参数"><a href="#JVM内存参数" class="headerlink" title="JVM内存参数"></a>JVM内存参数</h1><p>启动速度是没办法变快了，但是内存还是有很多可以调整的地方。</p><h2 id="最大堆内存"><a href="#最大堆内存" class="headerlink" title="最大堆内存"></a>最大堆内存</h2><pre><code>-Xmx=Your_size -Xms=Your_size</code></pre><p>这是第一个可以加的内存参数，也是最没用的一个。他能限制堆的大小，让gc触发的更加频繁一点，但是往往我们的启动内存就已经超过100M了，这里的设置根本没有效果。</p><h2 id="冗余度控制"><a href="#冗余度控制" class="headerlink" title="冗余度控制"></a>冗余度控制</h2><pre><code>-XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=10</code></pre><p>这行的效果非常好，默认的两个值似乎是50和70，这样内存的浪费就太多了。把两个值调到10之后整体的内存占用一下就少了很多。</p><h2 id="最大直接内存"><a href="#最大直接内存" class="headerlink" title="最大直接内存"></a>最大直接内存</h2><pre><code>-XX:MaxDirectMemorySize=12m</code></pre><p>如果有用像netty这样的框架，那这个设置就比较有用了。</p><h2 id="nio缓存"><a href="#nio缓存" class="headerlink" title="nio缓存"></a>nio缓存</h2><pre><code>-Djdk.nio.maxCachedBufferSize=262144</code></pre><p>跟上面一样，如果使用了nio或者netty的东西，加上这个参数之后可以限制缓存的大小。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JVM的许多默认设置都是以空间换时间的策略，在服务端上这样的策略当然有利于节约CPU资源，但是对于客户端程序来说，本身所需要的CPU就不高，这样的策略在用户看来就是程序占用了大量的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;还是我的Wsocks(不过现在改名SuperEngine了)，在兜兜转转了许久之后还是回到了最初的起点。要什么Kotlin Native，要
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://wooyme.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写编程语言(2)</title>
    <link href="http://wooyme.github.io/2019/11/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-2/"/>
    <id>http://wooyme.github.io/2019/11/22/自己动手写编程语言-2/</id>
    <published>2019-11-21T17:08:27.000Z</published>
    <updated>2019-11-22T06:33:42.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>把修改后的上传到了我的仓库</p><blockquote><p><a href="https://github.com/Wooyme/NMSL" target="_blank" rel="noopener">https://github.com/Wooyme/NMSL</a></p></blockquote><p>顺便取了个意义不明的名字<code>Naive Mind Specialize Language</code>，简称nmsl。</p><p>这篇先写一点原理相关的东西，然后就是lambda。</p><h1 id="编译期与运行期"><a href="#编译期与运行期" class="headerlink" title="编译期与运行期"></a>编译期与运行期</h1><p>开发语言和开发应用最大的区别就是语言开发中我们要预想的情况并不是程序的运行情况而是语言编译的情况。把运行和编译的逻辑理清楚后就能理解很多东西了。</p><p>英语比较好的话可以看一下</p><blockquote><p> <a href="https://www.youtube.com/watch?v=FJY96_6Y3a4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=FJY96_6Y3a4</a></p><p>《 One VM to Rule Them All, One VM to Bind Them》</p></blockquote><p>是Oracle Labs的人做的演讲。比较尴尬的是没有英文字幕，只能完全靠听力了。</p><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>首先我们看到<code>parser</code>包下的<code>SLNodeFactory</code>里有大量的<code>createXXX</code>的方法，而在<code>nodes</code>目录下都是继承了<code>Node</code>的类。了解过编译原理的朋友肯定知道编译器首先要解析语法然后生成相应的语法树，那么既然有树就肯定会有节点，而<code>Node</code>类代表的就是这些节点。  </p><p><code>SimpleLanguage</code>中有<code>builtin</code>，<code>expression</code>，<code>controlflow</code>，<code>local</code>这4个包，分别包含了内置函数，表达式，控制流和局部读写的节点。</p><h2 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h2><p><code>Expression</code>是比较简单的一种节点，功能上和<code>builtin</code>类似，但是与语法解析过程的联系更加紧密一些。</p><p>首先以<code>SLBigIntegerLiteralNode.java</code>为例。</p><pre><code class="java">@NodeInfo(shortName = &quot;const&quot;)public final class SLBigIntegerLiteralNode extends SLExpressionNode {    private final SLBigNumber value;    public SLBigIntegerLiteralNode(BigDecimal value) {        this.value = new SLBigNumber(value);    }    @Override    public SLBigNumber executeGeneric(VirtualFrame frame) {        return value;    }}</code></pre><p>这个是涉及code generate最少的一个类了，所以就以它为例。<code>SLBigIntegerLiteralNode</code>总共就一个构造函数和一个<code>executeGeneric</code>方法。这里就出现了一个生命周期的问题。<strong>SLBigIntegerLiteralNode在生成语法树的过程中被实例化</strong>而<strong>executeGeneric是在代码运行的时候被调用</strong></p><p>所以就有了<code>SLBigIntegerLiteralNode</code>中的操作，在生成语法树的过程中把常量<code>value</code>保存在类里，然后在<code>executeGeneric</code>中直接返回这个保存的值。</p><h2 id="更复杂的Expression"><a href="#更复杂的Expression" class="headerlink" title="更复杂的Expression"></a>更复杂的Expression</h2><p>以<code>SLWritePropertyNode</code>为例</p><pre><code class="java">@NodeInfo(shortName = &quot;.=&quot;)@NodeChild(&quot;receiverNode&quot;)@NodeChild(&quot;nameNode&quot;)@NodeChild(&quot;valueNode&quot;)public abstract class SLWritePropertyNode extends SLExpressionNode {    static final int LIBRARY_LIMIT = 3;    @Specialization(guards = &quot;arrays.hasArrayElements(receiver)&quot;, limit = &quot;LIBRARY_LIMIT&quot;)    protected Object write(Object receiver, Object index, Object value,                    @CachedLibrary(&quot;receiver&quot;) InteropLibrary arrays,                    @CachedLibrary(&quot;index&quot;) InteropLibrary numbers) {        try {            arrays.writeArrayElement(receiver, numbers.asLong(index), value);        } catch (UnsupportedMessageException | UnsupportedTypeException | InvalidArrayIndexException e) {            throw SLUndefinedNameException.undefinedProperty(this, index);        }        return value;    }    @Specialization(limit = &quot;LIBRARY_LIMIT&quot;)    protected Object write(Object receiver, Object name, Object value,                    @CachedLibrary(&quot;receiver&quot;) InteropLibrary objectLibrary,                    @Cached SLToMemberNode asMember) {        try {            objectLibrary.writeMember(receiver, asMember.execute(name), value);        } catch (UnsupportedMessageException | UnknownIdentifierException | UnsupportedTypeException e) {            // write was not successful. In SL we only have basic support for errors.            throw SLUndefinedNameException.undefinedProperty(this, name);        }        return value;    }}</code></pre><p>首先看到的是多了几个<code>NodeChild</code>的类注解以及<code>Specialization</code>的方法注解。刚刚也提到了code generate，所以这两个注解很明显就是和代码生成相关的。比较一下和上面的区别。发现<code>SLWritePropertyNode</code>是abstract的也没有实现<code>executeGeneric</code>方法，这就说明生成的代码为我们做了不少事情。</p><p>代码生成器生成的代码就不贴了，转述一下《 One VM to Rule Them All, One VM to Bind Them》里的话：</p><p><code>@NodeChild(&quot;receiverNode&quot;)</code>会生成<code>private final Node receiverNode;</code>同时会生成<code>create(Node receiverNode)</code>方法，而三个<code>NodeChild</code>自然就会生成三个这样的属性和三个create的参数。</p><p>与这些node相对的是带有<code>Specialization</code>注解的方法的参数，<strong>这个对应关系只与顺序相关，与名称是无关的</strong>。在运行过程中，生成的代码会调用三个子Node的<code>executeGeneric</code>方法得到值，然后传入到带有<code>Specialization</code>注解的方法中。</p><h2 id="Node总结"><a href="#Node总结" class="headerlink" title="Node总结"></a>Node总结</h2><p>与<code>ExpressionNode</code>相同，其他几类Node的生命周期也是这样。不过有些细节上的区别。比如<code>Builtins</code>会在<code>SLContext</code>里被提前install。</p><pre><code class="java">    //SLContext中安装内置函数    private void installBuiltins() {        installBuiltin(SLReadlnBuiltinFactory.getInstance());        installBuiltin(SLPrintBuiltinFactory.getInstance());        installBuiltin(SLNanoTimeBuiltinFactory.getInstance());        installBuiltin(SLDefineFunctionBuiltinFactory.getInstance());        installBuiltin(SLStackTraceBuiltinFactory.getInstance());        installBuiltin(SLNewObjectBuiltinFactory.getInstance());        installBuiltin(SLEvalBuiltinFactory.getInstance());        installBuiltin(SLGetSizeBuiltinFactory.getInstance());        installBuiltin(SLHasSizeBuiltinFactory.getInstance());        installBuiltin(SLIsExecutableBuiltinFactory.getInstance());        installBuiltin(SLIsNullBuiltinFactory.getInstance());        installBuiltin(SLWrapPrimitiveBuiltinFactory.getInstance());        installBuiltin(SLMembersBuiltinFactory.getInstance());        installBuiltin(SLOpenBuiltinFactory.getInstance());        installBuiltin(SLWriteBuiltinFactory.getInstance());        installBuiltin(SLCloseBuiltinFactory.getInstance());        installBuiltin(SLReadBuiltinFactory.getInstance());        installBuiltin(SLSleepBuiltinFactory.getInstance());        installBuiltin(SLInterfaceBuiltinFactory.getInstance());        installBuiltin(SLToIntNodeFactory.getInstance());        installBuiltin(SLFromProxyBuiltinFactory.getInstance());        installBuiltin(SLUnInterfaceBuiltinFactory.getInstance());    }</code></pre><h1 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h1><p>可以看到在<code>SLWritePropertyNode</code>中有这样一个方法。</p><pre><code class="java">    @Specialization(guards = &quot;arrays.hasArrayElements(receiver)&quot;, limit = &quot;LIBRARY_LIMIT&quot;)    protected Object write(Object receiver, Object index, Object value,                    @CachedLibrary(&quot;receiver&quot;) InteropLibrary arrays,                    @CachedLibrary(&quot;index&quot;) InteropLibrary numbers) {        try {            arrays.writeArrayElement(receiver, numbers.asLong(index), value);        } catch (UnsupportedMessageException | UnsupportedTypeException | InvalidArrayIndexException e) {            throw SLUndefinedNameException.undefinedProperty(this, index);        }        return value;    }</code></pre><p>这里出现了<code>InteropLibrary</code>这个类型，根据注解可以看出来，<code>InteropLibrary</code>和前面的<code>Object</code>是有关的。这里具体是什么关系很难直接说明，但是可以看到在<code>SLObjectType</code>与<code>SLBigNumber</code>这两个类的注解中均出现了<code>InteropLibrary.class</code>。这就是Truffle API让人用着很不爽的地方，它大量的使用了注解和代码生成，让代码结构非常混乱，而且还找不到文档。如果不看完那3个小时的视频很多地方就很难理解。</p><p>现在已知的是，可以从<code>receiver</code>和<code>index</code>中产生它们对应的<code>InteropLibrary</code>，也就是这里的<code>arrays</code>和<code>numbers</code>。</p><p>然后在<code>@Specialization</code>的注解中可以看到<code>guards</code>属性，从字面意思上就可以看出这个属性会生成用于保证方法正确运行的代码。因为这个<code>write</code>方法是要向array写入，所以这里的<code>receiver</code>就必须是array，于是就有了guards里的代码，保证receiver是有数组元素的。</p><p>但是！事实上，我们想要的往往是<code>List</code>，而不是一个<code>Array</code>，所以为了实现往<code>List</code>里写入元素只要加入这样一个方法。</p><pre><code class="java">    @Specialization(limit = &quot;LIBRARY_LIMIT&quot;)    protected Object write(List receiver, Object index, Object value,                           @CachedLibrary(&quot;index&quot;) InteropLibrary numbers){        try {            receiver.set(numbers.asInt(index),value);         } catch (UnsupportedMessageException | IndexOutOfBoundsException e) {            throw SLUndefinedNameException.undefinedProperty(this, index); // 如果超出list长度，则报错        }        return value;    }</code></pre><p>这里问题就来了，<code>List</code>是一个已知的类型，而前面的<code>Object</code>传进来的很明显也应该是一个已知的类型。那么这个<code>Object</code>会是什么呢？</p><h2 id="DynamicObject"><a href="#DynamicObject" class="headerlink" title="DynamicObject"></a>DynamicObject</h2><p>事实上，这个Object对应的是<code>DynamicObject</code>，而<code>DynamicObject</code>的最终实现则是<code>runtime</code>包下的<code>SLObjectType</code>。能看出<code>SLObjectType</code>即是<code>DynamicObject</code>的最直接证据就是<code>SLObjectType</code>的类注解</p><pre><code class="java">@ExportLibrary(value = InteropLibrary.class, receiverType = DynamicObject.class)</code></pre><p>这个连接过程有大量的代码生成来实现。</p><p>可以看到<code>SLObjectType</code>实现了<code>hasArrayElements</code>，<code>hasMembers</code>等方法，还有<code>GetMembers</code>,<code>ReadMember</code>,<code>WriteMember</code>这些子类。从字面意思上都可以看出这些东西的功能，但是在代码上完全看不出它们与<code>DynamicObject</code>或是<code>InteropLibrary</code>的关系。</p><p>如果想要知道<code>SLObjectType</code>中这些方法与<code>InteropLibrary</code>的关系，可以看<code>com.oracle.truffle.api.interop.InteropLibaray</code>的源码。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>花了很大的篇幅写ExpressionNode，所以Lambda放到下一篇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;把修改后的上传到了我的仓库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Wooyme/N
      
    
    </summary>
    
    
      <category term="NMSL" scheme="http://wooyme.github.io/tags/NMSL/"/>
    
      <category term="编译" scheme="http://wooyme.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写编程语言（1）</title>
    <link href="http://wooyme.github.io/2019/11/09/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <id>http://wooyme.github.io/2019/11/09/自己动手写编程语言/</id>
    <published>2019-11-09T15:09:50.000Z</published>
    <updated>2019-11-09T13:17:22.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然看到了graal的<em>SimpleLanguage</em>的demo</p><blockquote><p><a href="https://github.com/graalvm/simplelanguage" target="_blank" rel="noopener">https://github.com/graalvm/simplelanguage</a></p></blockquote><p>然后突发奇想，干脆自己写个语言吧。<br>于是就有了这篇博客。</p><p><em>到现在我的这个玩具语言甚至加入了lambda支持，而从我下载这个demo到现在大概过了3天左右。</em></p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>准备工作可以看官网上的文档，写的非常详细</p><blockquote><p><a href="https://www.graalvm.org/docs/graalvm-as-a-platform/implement-language/" target="_blank" rel="noopener">https://www.graalvm.org/docs/graalvm-as-a-platform/implement-language/</a></p></blockquote><h1 id="去他妈的整数"><a href="#去他妈的整数" class="headerlink" title="去他妈的整数"></a>去他妈的整数</h1><p>好的，拿到这个demo之后发现的第一个事情就是这货的数字类型只支持整数不支持浮点数。所以就从让它支持浮点数开始吧</p><h2 id="浮点数的语法"><a href="#浮点数的语法" class="headerlink" title="浮点数的语法"></a>浮点数的语法</h2><p>浮点数得有点，那么这里就需要改动关于语法解析的文件了。可以在</p><blockquote><p>language/src/main/java/com/oracle/truffle/sl/parser</p></blockquote><p>里找到<strong>SimpleLanguage.g4</strong>文件，在最下方可以看到关于<em>NUMERIC_LITERAL</em>的定义。</p><pre><code class="antlr4">NUMERIC_LITERAL : &#39;0&#39; | NON_ZERO_DIGIT DIGIT*</code></pre><p>可以看到跟正则的语法非常像，“|”代表“或”、“*”代表“匹配0次到无数次”。那么根据这个匹配规则就可以发现，在语法解析的过程中就没有提供对小数点的支持。所以我们第一步要做的就是在语法解析中加入小数点。</p><p>这个修改非常简单</p><pre><code class="antlr4">NUMERIC_LITERAL : &#39;0&#39; | NON_ZERO_DIGIT DIGIT* | &#39;0&#39; &#39;.&#39; DIGIT* | NON_ZERO_DIGIT DIGIT* &#39;.&#39; DIGIT*;</code></pre><p>这就是我改动后的结果。加入了两个新的规则。分别表示”0.xxxxx”和’xxx.xxxxx’这样两种情况。总的来说唯一要注意的就是在表示数字的语法中，要阻止”0xxx”这种写法的存在。</p><h3 id="重新生成文件"><a href="#重新生成文件" class="headerlink" title="重新生成文件"></a>重新生成文件</h3><p>g4文件需要被antlr转换为java文件之后才能参与编译。由于我用的ide是Intellij IDEA所以就装了antlr4的插件。安装完之后就可以在底部工具栏中看到<em>antlr preview</em>和<em>antlr output</em>两栏。其中<em>preview</em>可以用于查看语法解析树,，<em>output</em>可以查看生成java文件时的错误等。</p><p>在工程中右键<em>SimpleLanguage.g4</em> -&gt; 单击<em>generate ANTLR recognizer</em>生成java文件-&gt; 复制生成的文件到<em>SimpleLanguage.g4</em>所在目录就可以生效了。</p><h2 id="浮点数的实现"><a href="#浮点数的实现" class="headerlink" title="浮点数的实现"></a>浮点数的实现</h2><p>修改了浮点数的解析之后，需要在后端完成浮点数的实现。对于数字类型，SimpleLanguage使用了<em>BigInteger</em>，而我们需要把它改成<em>BigDecimal</em>才能支持浮点数。</p><p>在<code>runtime</code>包下可以找到<code>SLBigNumber</code>这个类。类里面有一个<code>BigInteger</code>的属性。我们只要把这个属性的类型改成<code>BigDecimal</code>再把其他跟这个属性相关的部分修改一下，能编译通过就OK了。</p><h2 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h2><p>重新编译只要在<code>simplelanguage</code>目录下<code>mvn clean package -DskipTests</code>即可，不想要编译native的话，可以在<code>native\make_native.sh</code>里加入</p><pre><code>SL_BUILD_NATIVE=&quot;false&quot;</code></pre><p>顺便一提，maven3好像有点bug。因为代码里存在大量的代码生成，这些生成的文件在<code>target\generated-sources\annotations</code>里。一般情况下maven是能找到这个目录的，但有时候在<code>clean</code>之后maven就找不到了。</p><p>我的解决方案是如果出现了找不到的情况就在<code>simplelanguage</code>module的<code>pom.xml</code>里加上</p><pre><code class="xml">      &lt;plugin&gt;        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;3.0.0&lt;/version&gt;        &lt;executions&gt;          &lt;execution&gt;            &lt;id&gt;add-source&lt;/id&gt;            &lt;phase&gt;generate-sources&lt;/phase&gt;            &lt;goals&gt;              &lt;goal&gt;add-source&lt;/goal&gt;            &lt;/goals&gt;            &lt;configuration&gt;              &lt;sources&gt;                &lt;source&gt;target/generated-sources/annotations&lt;/source&gt;              &lt;/sources&gt;            &lt;/configuration&gt;          &lt;/execution&gt;        &lt;/executions&gt;      &lt;/plugin&gt;</code></pre><p>然后再clean，package。成功打包之后注释掉这段，就可以重归正常了。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>SimpleLanguage的字符串不支持<code>\r\n\t\&quot;</code>。这肯定不行，所以我们得自己加一个。<br>与修改数字一样，我们要先修改语法解析的东西。</p><p>原本的格式</p><pre><code>fragment STRING_CHAR : ~( &#39;\\&#39; | &#39;&quot;&#39; | &#39;\r&#39; | &#39;\n&#39;);STRING_LITERAL : &#39;&quot;&#39; STRING_CHAR* &#39;&quot;&#39;;</code></pre><p>修改后的格式</p><pre><code>fragment STRING_CHAR :  &#39;\\\\&#39; | &#39;\\&quot;&#39;| &#39;\\n&#39; | &#39;\\t&#39; | &#39;\\r&#39; | ~( &#39;\\&#39; | &#39;&quot;&#39; | &#39;\r&#39; | &#39;\n&#39;);STRING_LITERAL : &#39;&quot;&#39; STRING_CHAR* &#39;&quot;&#39;;</code></pre><p>原本的字符串里是不能出现<code>\</code>的，现在虽然保留了最初的部分，但是我们添加了几种其他选项<code>&#39;\\\\&#39;  |  &#39;\\&quot;&#39;| &#39;\\n&#39; | &#39;\\t&#39; | &#39;\\r&#39;</code>。于是解析的时候就会优先匹配前几种。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>前端匹配了并没有什么卵用，如果不修改其他部分，最终得到的也只是把这些东西原封不动的输出而已。所以我们还要修改<code>nodes/expression/SLStringLiteralNode.java</code>。我的方案是在编译期就替换掉这些字符串。</p><pre><code class="java">@NodeInfo(shortName = &quot;const&quot;)public final class SLStringLiteralNode extends SLExpressionNode {    private static HashMap&lt;Character,Character&gt; specialCharMap = new HashMap&lt;&gt;();    // 创建特殊字符替换表    static {        specialCharMap.put(&#39;n&#39;,&#39;\n&#39;);        specialCharMap.put(&#39;r&#39;,&#39;\r&#39;);        specialCharMap.put(&#39;t&#39;,&#39;\t&#39;);        specialCharMap.put(&#39;&quot;&#39;,&#39;&quot;&#39;);    }     private final String value;    public SLStringLiteralNode(String value) {        char[] chars = value.toCharArray();        StringBuilder sb = new StringBuilder();        int status = 0;        for (char aChar : chars) {            if (aChar == &#39;\\&#39;) {                if (status == 0)                    status = 1;                else {                    status = 0;                    sb.append(&#39;\\&#39;); //针对\\的情况                }            } else {                if (status == 1) {                    if (specialCharMap.containsKey(aChar)) {                        sb.append(specialCharMap.get(aChar)); //替换字符                        status = 0;                    } else {                        throw new RuntimeException(&quot;Failed to parse string&quot;); //随便弹个异常                    }                } else {                    sb.append(aChar); //普通字符                }            }        }        this.value = sb.toString();    }    @Override    public String executeGeneric(VirtualFrame frame) {        return value;    }}</code></pre><p>这样在运行的时候，得到的就是已经替换特殊字符的字符串。</p><h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><p>语言到了这里，还有一个很重要的问题——没有Boolean值。最初我想的是，没有布朗值那就没有呗，就用0和非0来表示。但是观察了一下SimpleLanguage写好的几个内置函数(内置函数下一篇再说)是有返回bool的，而且<code>==</code>这样的关键字也是有对bool的比较。所以还是加一个吧</p><h2 id="增加规则"><a href="#增加规则" class="headerlink" title="增加规则"></a>增加规则</h2><p>和数字、字符串一样，我们希望可以直接使用<code>true</code>和<code>false</code></p><pre><code>a = &quot;Hello&quot;;b = 123.1;c = false;</code></pre><p>所以在g4文件里要加入对<code>true</code>和<code>false</code>的支持</p><pre><code>LOGICAL_LITERAL : &#39;true&#39; | &#39;false&#39;;   //添加用于匹配true和false的规则IDENTIFIER : LETTER (LETTER | DIGIT)*;STRING_LITERAL : &#39;&quot;&#39; STRING_CHAR* &#39;&quot;&#39;;NUMERIC_LITERAL : &#39;0&#39; | NON_ZERO_DIGIT DIGIT* | &#39;0&#39; &#39;.&#39; DIGIT* | NON_ZERO_DIGIT DIGIT* &#39;.&#39; DIGIT*;</code></pre><pre><code class="antlr4">factor returns [SLExpressionNode result]:(    LOGICAL_LITERAL                             { $result = factory.createLogicalLiteral($LOGICAL_LITERAL); } //添加匹配LOGICAL_LITERAL，一定要放在前面，不然就优先匹配IDENTIFIER了。|    IDENTIFIER                                  { SLExpressionNode assignmentName = factory.createStringLiteral($IDENTIFIER, false); }    (        member_expression[null, null, assignmentName] { $result = $member_expression.result; }    |                                                { $result = factory.createRead(assignmentName); }    )|    STRING_LITERAL                              { $result = factory.createStringLiteral($STRING_LITERAL, true); }|    NUMERIC_LITERAL                             { $result = factory.createNumericLiteral($NUMERIC_LITERAL); }|    lmbd=lambda                                 { $result = $lmbd.result; }|    s=&#39;(&#39;    expr=expression    e=&#39;)&#39;                                       { $result = factory.createParenExpression($expr.result, $s.getStartIndex(), $e.getStopIndex() - $s.getStartIndex() + 1); });</code></pre><p>可以看到我加了个<code>createLogicalLiteral</code>方法给factory。这是第一次提到factory。看一下g4文件members的部分就可以发现这个<code>factory</code>就是<code>SLNodeFactory</code>。里面提供了许多封装好的创建节点的方法。</p><h2 id="LogicalLiteral"><a href="#LogicalLiteral" class="headerlink" title="LogicalLiteral"></a>LogicalLiteral</h2><p>前面我们已经看到了<code>StringLiteral</code>,其实还有<code>BigIntegerLiteral</code>(当然这个BigInteger现在已经是BigDecimal了)。这里<code>Literal</code>是字面的意思，这里我也不太想得到一个合适的翻译，大家自己领会了。</p><p>我们要能在代码里表示一个布朗值就需要定义一个布朗的字面量，所以我写了一个<code>SLLogicalLiteralNode</code></p><pre><code class="java">@NodeInfo(shortName = &quot;const&quot;)public final class SLLogicalLiteralNode extends SLExpressionNode {    private final Boolean value;    public SLLogicalLiteralNode(boolean value){        this.value = value;    }    @Override    public Boolean executeGeneric(VirtualFrame frame) {        return value;    }}</code></pre><p>非常简单，在编译期把<code>value</code>放进去，然后在运行期取出来用。<br>然后在<code>SLNodeFactory</code>里添加<code>createLogicalLiteral</code>方法</p><pre><code class="java">    public SLExpressionNode createLogicalLiteral(Token literalToken){        SLExpressionNode result;        result = new SLLogicalLiteralNode(Boolean.parseBoolean(literalToken.getText()));        srcFromToken(result, literalToken);        result.addExpressionTag();        return result;    }</code></pre><p>这样我们就可以直接写<code>true</code>和<code>false</code>了</p><h2 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h2><p>然后就发现问题了，SimpleLanguage连<code>!</code>操作符都没有。但是在<code>nodes</code>里我们可以找到<code>SLLogicalNotNode</code>,所以加一个<code>!</code>就只需要在语法解析上做点修改。</p><pre><code>term returns [SLExpressionNode result]:single_factor                                         { $result = $single_factor.result; }(    op=(&#39;*&#39; | &#39;/&#39;)    single_factor                                     { $result = factory.createBinary($op, $result, $single_factor.result); })*;single_factor returns [SLExpressionNode result]:(    (        &#39;!&#39;        factor  { $result = factory.createNot($factor.result); }    )|    factor  {$result = $factor.result; });</code></pre><p>我的方案是加了一个<code>single_factor</code>并把<code>term</code>内原本的<code>factor</code>改成<code>single_factor</code>。等于在原本的解析中插入一个对<code>!factor</code>的匹配。</p><p>这个匹配的写法应该是有很多的，我选了一个我第一反应想到的。</p><p>一通操作之后就可以实现这样一个基本的不能再基本的功能……..</p><pre><code>fn main(){    if(!false){        .........    }}</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>原理什么的其实我也还没完全理清楚，Truffle用了大量的注解和代码生成，导致写起来非常混乱。很多时候我也只能通过自己对于编译和虚拟机的理解去想代码运行的逻辑。下一篇是打算写一点我的理解和如何实现一个lambda。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;偶然看到了graal的&lt;em&gt;SimpleLanguage&lt;/em&gt;的demo&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="NMSL" scheme="http://wooyme.github.io/tags/NMSL/"/>
    
      <category term="编译" scheme="http://wooyme.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Cmake备忘录</title>
    <link href="http://wooyme.github.io/2019/11/04/Cmake%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://wooyme.github.io/2019/11/04/Cmake备忘录/</id>
    <published>2019-11-04T04:26:39.000Z</published>
    <updated>2019-11-05T05:36:50.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><pre><code>include_directories(        /PATH/TO/JDK/include)</code></pre><p>其他头文件同理<br>例：</p><pre><code>cmake_minimum_required(VERSION 3.14)project(JNI)set(CMAKE_CXX_STANDARD 14)include_directories(        /usr/local/graalvm/19.1.1/include)add_library(JNI SHARED library.cpp JNI.h)</code></pre><h1 id="linker-flags"><a href="#linker-flags" class="headerlink" title="linker flags"></a>linker flags</h1><pre><code>set (CMAKE_SHARED_LINKER_FLAGS &quot;-lpthread&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JNI&quot;&gt;&lt;a href=&quot;#JNI&quot; class=&quot;headerlink&quot; title=&quot;JNI&quot;&gt;&lt;/a&gt;JNI&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;include_directories(
        /PATH/TO/JDK/include
)
&lt;/code
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://wooyme.github.io/tags/C-C/"/>
    
      <category term="Cmake" scheme="http://wooyme.github.io/tags/Cmake/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x后端漫游指南(5)</title>
    <link href="http://wooyme.github.io/2019/10/28/Vert-x%E5%90%8E%E7%AB%AF%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97-5/"/>
    <id>http://wooyme.github.io/2019/10/28/Vert-x后端漫游指南-5/</id>
    <published>2019-10-28T11:10:14.000Z</published>
    <updated>2019-10-28T11:53:12.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>半年更的<em>Vert.x后端漫游指南又来了</em> 。这次的tags除了熟悉的<code>Vert.x</code>以外，还多了一个 <code>OpenAPI</code>。要是看过上一篇的话，应该会记得在上一篇中，我们使用了<code>Swagger</code>和<code>Web API Contract</code>来进行API的开发。而本篇我们要用一种更加简单的方式来编写API</p><h1 id="OpenAPI-Generator"><a href="#OpenAPI-Generator" class="headerlink" title="OpenAPI Generator"></a>OpenAPI Generator</h1><p>github</p><blockquote><p><a href="https://github.com/OpenAPITools/openapi-generator" target="_blank" rel="noopener">https://github.com/OpenAPITools/openapi-generator</a></p></blockquote><p>首先介绍一下<strong>openapi-generator</strong>，这是一个代码生成工具，可以看到在github上已经有超过3.5k的star。这个工具其实就是swagger的升级版，并且采用了社区化的开发方式，也就是说其他开发者也可以为开发团队提供代码，将自己想要的功能添加到openapi-generator中去。  </p><p>在老版本的openapi-generator中，已经集成了<strong>java-vertx</strong>的生成器，而在最新的4.2.0版本(<a href="https://oss.sonatype.org/content/repositories/snapshots/org/openapitools/openapi-generator-cli/4.2.0-SNAPSHOT/openapi-generator-cli-4.2.0-20191018.031007-71.jar)中加入了**kotlin-vertx(beta)**。于是*Vert.x后端漫游指南5*就有了着落。" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots/org/openapitools/openapi-generator-cli/4.2.0-SNAPSHOT/openapi-generator-cli-4.2.0-20191018.031007-71.jar)中加入了**kotlin-vertx(beta)**。于是*Vert.x后端漫游指南5*就有了着落。</a></p><p>顺带一提，<strong>kotlin-vertx</strong>的贡献者是我。再顺带一提，<strong>有bug</strong>。</p><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><p>下载openapi-generator之后，从终端启动</p><pre><code>java -jar openapi-generator-cli-4.2.0.jar generate -g kotlin-vertx -i example.yaml -o server</code></pre><p>会生成出一个<code>server</code>文件夹，里面是一个完整的<em>maven</em>工程。在其中的verticle目录下，可以看到三种文件，分别是<code>XXApi</code><br>,<code>XXApiVerticle</code>和<code>XXApiVertxProxyHandler</code>，而我们要做的只有新建一个<code>XXApiImpl</code>，继承<code>XXApi</code>，实现里面的所有方法。</p><h1 id="继承Api"><a href="#继承Api" class="headerlink" title="继承Api"></a>继承Api</h1><p>Api文件中大概是这个样子的</p><pre><code class="kotlin">interface MyApi  {    suspend fun listData(deviceId:kotlin.String?,sensorId:kotlin.Int?,offset:kotlin.Int?,limit:kotlin.Int?,start:kotlin.Long?,end:kotlin.Long?,context:OperationRequest):Response&lt;kotlin.Array&lt;Data&gt;&gt;    companion object {        const val address = &quot;MyApi-service&quot;        suspend fun createRouterFactory(vertx: Vertx,path:String): io.vertx.ext.web.api.contract.openapi3.OpenAPI3RouterFactory {            val routerFactory = OpenAPI3RouterFactory.createAwait(vertx,path)            routerFactory.addGlobalHandler(CookieHandler.create())            routerFactory.addGlobalHandler(SessionHandler.create(LocalSessionStore.create(vertx)))            routerFactory.setExtraOperationContextPayloadMapper{                JsonObject().put(&quot;files&quot;,JsonArray(it.fileUploads().map { it.uploadedFileName() }))            }            val opf = routerFactory::class.java.getDeclaredField(&quot;operations&quot;)            opf.isAccessible = true            val operations = opf.get(routerFactory) as Map&lt;String, Any&gt;            for (m in LinkApi::class.java.methods) {                val methodName = m.name                val op = operations[methodName]                if (op != null) {                    val method = op::class.java.getDeclaredMethod(&quot;mountRouteToService&quot;,String::class.java,String::class.java)                    method.isAccessible = true                    method.invoke(op,address,methodName)                }            }            routerFactory.mountServiceInterface(LinkApi::class.java, address)            return routerFactory        }    }}</code></pre><p>其中，<code>companion object</code>是Api自己的东西，我们要自己重写<code>listData</code>方法。到这里就跟上一篇很像了，包括所使用的OperationRequest也是和上一篇中一模一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;半年更的&lt;em&gt;Vert.x后端漫游指南又来了&lt;/em&gt; 。这次的tags除了熟悉的&lt;code&gt;Vert.x&lt;/code&gt;以外，还多了一个 
      
    
    </summary>
    
    
      <category term="Vert.x" scheme="http://wooyme.github.io/tags/Vert-x/"/>
    
      <category term="OpenAPI" scheme="http://wooyme.github.io/tags/OpenAPI/"/>
    
  </entry>
  
  <entry>
    <title>ngx-smart-table备忘录</title>
    <link href="http://wooyme.github.io/2019/10/28/ngx-smart-table%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://wooyme.github.io/2019/10/28/ngx-smart-table备忘录/</id>
    <published>2019-10-28T10:25:45.000Z</published>
    <updated>2019-10-28T11:00:11.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>官网</p><blockquote><p><a href="https://akveo.github.io/ng2-smart-table/" target="_blank" rel="noopener">https://akveo.github.io/ng2-smart-table/</a></p></blockquote><p>github</p><blockquote><p><a href="https://github.com/akveo/ng2-smart-table" target="_blank" rel="noopener">https://github.com/akveo/ng2-smart-table</a></p></blockquote><p>examples</p><blockquote><p><a href="https://github.com/akveo/ng2-smart-table/tree/master/projects/demo/src/app/pages" target="_blank" rel="noopener">https://github.com/akveo/ng2-smart-table/tree/master/projects/demo/src/app/pages</a></p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre><code class="typescript">@Component({  selector: &#39;ngx-data&#39;,  template: `&lt;ng2-smart-table [settings]=&quot;settings&quot; [source]=&quot;source&quot;&gt;`,})export class DataComponent {  option:any;  settings = {    pager: {      display: true,      perPage: 50    },    actions: {  //修改ng2-smart-table自带的action列      add: false,        edit: false,      delete: false,    },    hideSubHeader: true, //隐藏顶栏    columns: {      col1: {        title: &#39;值&#39;,        type: &#39;string&#39;,      },      col2: {        title: &#39;更新时间&#39;,        type: &#39;string&#39;,      },    },  };  source: LocalDataSource;  }</code></pre><h1 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h1><pre><code class="javascript">pager:{    display: true , //是否显示分页器     perPage: 50 //每页显示数量}</code></pre><h2 id="后端分页"><a href="#后端分页" class="headerlink" title="后端分页"></a>后端分页</h2><p>后端分页可以继承<code>LocalDataSource</code>,写一个新的<code>DataSource</code>，重写<code>getElements()</code>和<code>count()</code>函数</p><pre><code class="typescript">export class MyDataSource extends LocalDataSource {  all: number;  devName: string;  namFilter:string;  constructor(private api: MyService) {    super()  }  count(): number {    return this.all;  }  getElements(): Promise&lt;any&gt; {    return this.api.getData(nameFilter).pipe(map(result=&gt;{  //假设返回为{&#39;count&#39;:100,data:[.......]}        this.all = result.count;        return result.data;    })).toPromise();  }}</code></pre><p>使用方式</p><pre><code class="typescript">source:MyDataSource = new DeviceDataSource(this.api);search(name:string){    this.source.nameFilter = name;    this.source.setPage(1);    this.source.refresh();}</code></pre><h1 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h1><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><pre><code class="javascript">columns: {      col1: {        title: &#39;链接&#39;,        type: &#39;html&#39;,      },}</code></pre><p>直接修改值为html代码</p><h2 id="方案2-自定义渲染器"><a href="#方案2-自定义渲染器" class="headerlink" title="方案2 自定义渲染器"></a>方案2 自定义渲染器</h2><pre><code class="typescript">import {Component, Input, OnInit} from &quot;@angular/core&quot;;import {ViewCell} from &quot;ng2-smart-table&quot;;@Component({  template: `    &lt;button (click)=&quot;onClick()&quot;&gt;{{renderValue}}&lt;/button&gt;  `,})export class CustomRender implements ViewCell, OnInit {  renderValue: string;  @Input() value: string | number; //对应列的值  @Input() rowData: any; //本行所有值:{&#39;col1&#39;:&#39;value1&#39;,&#39;col2&#39;,&#39;value2&#39;}  ngOnInit() {    this.renderValue = value;  }  onClick(){      console.log(rowData);  }}</code></pre><pre><code class="typescript">columns: {      col1: {        title: &#39;链接&#39;,        type: &#39;custom&#39;,        renderComponent: CustomRender      },}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;官网&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://akveo.github.io/ng2-sm
      
    
    </summary>
    
    
      <category term="Angular" scheme="http://wooyme.github.io/tags/Angular/"/>
    
      <category term="备忘录" scheme="http://wooyme.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>如何强上你的邻居</title>
    <link href="http://wooyme.github.io/2019/08/31/%E5%A6%82%E4%BD%95%E5%BC%BA%E4%B8%8A%E4%BD%A0%E7%9A%84%E9%82%BB%E5%B1%85/"/>
    <id>http://wooyme.github.io/2019/08/31/如何强上你的邻居/</id>
    <published>2019-08-31T13:11:08.000Z</published>
    <updated>2019-08-31T08:27:35.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Wsocks实现了一个很有意思的功能。所以写篇文章分享一下这个功能的一些细节。至于是什么样的功能，<strong>听说过伪造IP吗，朋友</strong>。</p><h1 id="我们的环境"><a href="#我们的环境" class="headerlink" title="我们的环境"></a>我们的环境</h1><p>我做这个测试的服务器地址是：<em>85.143.202.5</em>，一台来自毛子的VPS。</p><blockquote><p>既然用他们的机器搞事情了，那就推广一下作为赔偿吧。<br><a href="https://hexcore.ru" target="_blank" rel="noopener">https://hexcore.ru</a> 最便宜的是225卢布一个月，速度一般，但也还对的起这个价格。而且俄罗斯嘛，能干点别的地方不能干的事情。另外毛子比较耿直，所以年费没有优惠</p></blockquote><p>我的网关是<em>85.143.202.1</em>。我有一个邻居，<em>85.143.202.6</em>，当然我不止这一个邻居。在这里邻居的定义是跟我连在同一个交换机或是hub上的其他“机器”。由于现在都是虚拟服务器，所以这个“机器”的定义就比较模糊了，总之可以理解成其他的vps。</p><p>这个是ARP表</p><blockquote><p>85.143.202.6     f6:96:1e:7f:ce:e1<br>85.143.202.1     a8:d0:e5:54:35:20<br>85.143.202.4     f6:96:cd:84:83:c4         </p></blockquote><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>正常来说，我们用85.143.202.5这个IP收发消息，而我们的邻居用它们自己的IP收发消息，一切都很和谐。但是如果有一天，我们要干票大的或是干些什么见不得人的勾当，所以想<strong>借</strong>隔壁兄弟的身份证一用，那要怎么操作呢。<br>这个么，很明显有两种方案。一是闯进邻居的家里，拿走它的身份证，光明正大的去嫖娼，用完之后再还回去。这个方案非常OK，而且已经被沿用了很多年，但是问题就是，总有一天邻居会发现自己的家被人闯了，于是他决定换掉门锁，加固门窗，这样我们就很难再下手了。<br>另一种方式是我们伪造一张邻居的身份证出去招摇撞骗。对于这种方式呢，邻居除了报警之外，他自己是没有任何办法的。而且有可能报警也解决不了问题。</p><h1 id="伪造IP"><a href="#伪造IP" class="headerlink" title="伪造IP"></a>伪造IP</h1><p>在互联网上伪造身份证自然就是<strong>伪造IP</strong>了。玩过黑客的朋友多半听过一个名字——凯文·米特尼克。这位世界第一黑客，曾经就使用过伪造IP来完成攻击。不过虽然都是伪造IP，但是呢，一是凯文当时的年代网络环境简单，二是我们的目标并不是想要攻击谁，所以我们的和凯文之间的操作还是有很大区别的。</p><p>对于我们来说，最终的目标是要能用邻居的IP<strong>收发</strong>消息。为什么要强调<strong>收发</strong>呢，因为<strong>发</strong>其实是一件相对简单的事情，<strong>收</strong>才是整个过程的关键所在。</p><h2 id="用邻居的IP发"><a href="#用邻居的IP发" class="headerlink" title="用邻居的IP发"></a>用邻居的IP发</h2><p>在无论是windows还是linux提供的socket中都有一样叫做<strong>raw socket</strong>的东西。这个东西允许我们自己构造IP头，再构造TCP或是UDP的包，然后内核会不管三七二十一把这个我们自己构造的东西给发出去(<em>Windows似乎在某个版本禁止了使用rawsocket来修改IP，所以要完成这样的操作，还是用Linux吧</em>)。<br>在大多数情况下这个操作是可行的，但是只要稍微分析一下这样的包就会发现这种数据是有漏洞的。<br>我们都知道有个东西叫做<strong>ARP表</strong>，这张表我们有，我们连接着的路由(网关)也有。而这里有个最大的问题就是，所有的数据最后都会通过网关。而聪明一点的网关就会发现，你这个包里的MAC地址和IP咋就对不上呢。于是它有可能会丢掉这个包，或是把这个事件记录到日志里等管理员来看。总之不管是哪种最终都会导致我们的计划受阻。<br>那么最好的方案是什么呢。这里要提一个库<strong>libpcap</strong>，对应的Windows版本是<strong>WinPcap</strong>。pcap这个库可以让我们直接操作网卡发送以太网帧，这样我们可以编辑的就不只是IP了，连source mac都可以一起操作。<strong>需要注意的是，如果要发数据到其他子网，dest mac应该设置成网关的mac地址。</strong><br>放一段使用<code>Pcap4J</code>的代码演示一下这个过程</p><pre><code class="Kotlin">val nif = Pcaps.findAllDevs()[0]val sendHandle = nif.openLive(65536, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, 10)//用85.143.202.6的IP和MAC发一个UDP包给val udpBuilder = UdpPacket.Builder()    udpBuilder.srcAddr(Inet4Address.getByName(&quot;85.143.202.6&quot;))      .dstAddr(Inet4Address.getByName(&quot;8.8.8.8&quot;))      .srcPort(UdpPort((7777).toShort(), &quot;me&quot;))      .dstPort(UdpPort.DOMAIN) //表示53端口      .correctLengthAtBuild(true)      .correctChecksumAtBuild(true)    val ipV4Builder = IpV4Packet.Builder()      .version(IpVersion.IPV4)      .tos(IpV4Rfc791Tos.newInstance(0.toByte()))      .ttl(100.toByte())      .protocol(IpNumber.UDP)      .srcAddr(Inet4Address.getByName(&quot;85.143.202.6&quot;) as Inet4Address)      .dstAddr(Inet4Address.getByName(&quot;8.8.8.8&quot;) as Inet4Address)      .payloadBuilder(udpBuilder)      .correctChecksumAtBuild(true)      .correctLengthAtBuild(true)    val etherBuilder = EthernetPacket.Builder()    etherBuilder      .dstAddr(MacAddress.getByName(&quot;a8:d0:e5:54:35:20&quot;))      .srcAddr(MacAddress.getByName(&quot;f6:96:1e:7f:ce:e1&quot;))      .type(EtherType.IPV4)      .paddingAtBuild(true)    val ipV4Packet = IpV4Helper.fragment(ipV4Builder.build(), 1200)[0]    etherBuilder.payloadBuilder(      object : AbstractPacket.AbstractBuilder() {        override fun build(): Packet {          return ipV4Packet        }      }).build()      sendHandle.sendPacket(etherBuilder.build())</code></pre><p>OK，这样我们的数据就和正常的流量没有任何区别了。</p><blockquote><p>事实上，如果只是想实现用别人的IP发送数据的话，限制可以小很多。我们一般可以使用整个C类段，甚至是好几个C类段里的IP。这个主要是跟网关的逻辑和虚拟化使用的技术有关。</p></blockquote><h1 id="用邻居的IP收"><a href="#用邻居的IP收" class="headerlink" title="用邻居的IP收"></a>用邻居的IP收</h1><p>发送是一件很简单的事情，但是收就难了。这就好比你寄快递，即使填了个假的发件地址，收件人也还是可以收到邮件的。但是你如果填一个假的收件地址还想让快递小哥把快递送到你家，就很有难度了。</p><h2 id="骗谁"><a href="#骗谁" class="headerlink" title="骗谁"></a>骗谁</h2><p>要想实现这样一个收的操作，就必须要欺骗一些设备了。让我们看看有哪些设备是跟我们有关系的。</p><h3 id="ARP？"><a href="#ARP？" class="headerlink" title="ARP？"></a>ARP？</h3><p>首先是<strong>网关</strong>，发到我们所在的子网的所有数据都会先发到网关那，所以要是能骗网关直接把数据发给我们，那不就万事大吉了。那么这个能做到吗？答案是肯定的。曾有一招从天而降的掌法，如来..呃不，是<em>ARP攻击</em>。就如前面说的，网关它也维护着一张ARP表，里面记录着子网里所有IP和它MAC地址的对应关系。 </p><p>然而ARP这个东西是有漏洞的，我们只要一直给网关发假的ARP响应它就会信以为真把我们的MAC地址和我们邻居的IP地址对应到一块儿去。ARP的技术细节在这里就不多说了，Google一下已经有很多写的很详细的了。  </p><p>那么我们可以用ARP攻击吗？ 很显然不行。首先ARP攻击作为一个古老的攻击方式已经被很多路由器防范了。其次ARP攻击特征明显，很容易被运营商发现，然后把我们给ban了。</p><h3 id="换个傻子"><a href="#换个傻子" class="headerlink" title="换个傻子"></a>换个傻子</h3><p>那么网关不行，网关和我们中间的还有什么呢。这里存在两种情况。  </p><ol><li>我们和我们的邻居连在同一个hub上</li><li>我们和我们的邻居连在同一个交换机上</li></ol><p>如果是hub，那事情就很简单了。众所周知，hub就是个哈皮。它根本不知道连在它身上的都是些什么东西，它只知道自己的哪几个口有东西连上来了。所以一旦有数据发送到了hub这里，它会把这个数据给每个打开的端口(<em>这个端口不是UDP或TCP的端口，而是类似网线接口的那种端口</em>)都发一份。这就等于说邻居收到的数据本来就会给我们发一份，只是平时网卡无视了它。那么我们只要用pcap抓一下包就解决了。  </p><p>而到了交换机上，事情就变得复杂了一点。交换机没这么愚蠢，它内部维护着一张端口和MAC地址的表。一旦有数据到了它这里，它会查看一下数据的目标MAC，然后在自己的对应表里查找对应的端口，并且把数据转发到这个端口。<br>那么这里就有一个问题，交换机是怎么维护这张表的？ 首先交换机只能理解L2的东西，也就是说，不管什么协议的数据经过了交换机，它只在乎源MAC和目标MAC。交换机维护对应表的策略非常简单。查看所有数据的源MAC地址，然后把这个源MAC地址和数据来自的端口对应起来。至于出现了目标MAC地址不在表里的情况，交换机就会像Hub一样广播这个数据。  </p><p>既然交换机是这么维护对应表的，那一切就很明了了。</p><h2 id="欺骗一台交换机"><a href="#欺骗一台交换机" class="headerlink" title="欺骗一台交换机"></a>欺骗一台交换机</h2><p>要骗一台交换机很简单，一个正经的流量就可以欺骗它。我们只需要像前面一样，伪造邻居的IP和MAC随便发点数据就行了。唯一的附加条件是，我们发送的频率要足够高，这样才能够一直抢占邻居的位置。当然了，一旦我们抢占了邻居的位置，那我们的邻居就再也收不到任何数据了。<br>这种方式相对于ARP攻击要更加隐蔽，对于一些老交换机来说甚至是无法被发现的。</p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>现在我们有了邻居的公网IP了。<br>对于Wsocks来说，如此折腾了一圈，最终的目的是个自己加点应对GFW的筹码，而且总的看来只是个花里胡哨的把式而已。但是其实这种hack完全可以带来更多的东西，比如类似旁站攻击的操作，或是嫁祸于人的障眼法。要怎么用，还是看最终想要做什么。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Wsocks实现了一个很有意思的功能。所以写篇文章分享一下这个功能的一些细节。至于是什么样的功能，&lt;strong&gt;听说过伪造IP吗，朋友&lt;/
      
    
    </summary>
    
    
      <category term="网络" scheme="http://wooyme.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="hack" scheme="http://wooyme.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>C++ Macro,  FUCK YOU!</title>
    <link href="http://wooyme.github.io/2019/06/04/C-Macro-FUCK-YOU/"/>
    <id>http://wooyme.github.io/2019/06/04/C-Macro-FUCK-YOU/</id>
    <published>2019-06-04T13:10:26.000Z</published>
    <updated>2019-08-18T16:59:45.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天一直在搞Javafx和Graalvm。主要是Graalvm在Windows上编译native image问题太tm多了。主要问题都出在JNI的部分，现在已经发现有数组访问异常，浮点数传递不正确的bug。要是有人想尝试一下native image在windows上的效果的话，最好先从不涉及jni的库开始。<br>那么，这篇的主题其实跟graalvm没什么关系，开篇只是发个牢骚。当然了，要是没有Graalvm的这些问题，我也不至于把JavaFx的C++实现全给看一遍，也就不会有这篇博客了。</p><h1 id="宏-Macro"><a href="#宏-Macro" class="headerlink" title="宏(Macro)"></a>宏(Macro)</h1><p>虽然我第一次写C++的程序是在2012年，但是其实我的C++是写的很烂的。所以在很长的一段时间里，宏在我的认知里无非是做一些编译期的判断，像是实现DEBUG和RELEASE分支，或是防止头文件被重复引用这样的小事情。唯一跟代码相关的，也就是会把常量定义在宏里。</p><p>因此Graalvm和JavaFx的一些宏操作彻底闪瞎了我的狗眼。先从Graalvm的说起吧。</p><h2 id="Code-Generator-Macro-Version"><a href="#Code-Generator-Macro-Version" class="headerlink" title="Code Generator( Macro Version! )"></a>Code Generator( Macro Version! )</h2><p>代码生成器这种东西各位应该或多或少都接触过。这个东西在Java里可以说是各大框架的杀手锏，你给个接口，他替你实现。在没有宏定义的Java里，框架用各种代码生成工具来实现代码生成，而在C/C++的世界里，代码生成器又可以是什么样子的呢</p><p>先来看一段Graalvm的官方demo</p><pre><code class="C">#include &lt;polyglot.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct Point {    double x;    double y;};POLYGLOT_DECLARE_STRUCT(Point)void *allocNativePoint() {    struct Point *ret = malloc(sizeof(*ret));    return polyglot_from_Point(ret);}void *allocNativePointArray(int length) {    struct Point *ret = calloc(length, sizeof(*ret));    return polyglot_from_Point_array(ret, length);}void freeNativePoint(struct Point *p) {    free(p);}void printPoint(struct Point *p) {    printf(&quot;Point&lt;%f,%f&gt;\n&quot;, p-&gt;x, p-&gt;y);}</code></pre><p>实现了什么功能不重要，重要的是其中的<code>POLYGLOT_DECLARE_STRUCT</code>和<code>polyglot_from_Point</code>以及<code>polyglot_from_Point_array</code>这三个东西。</p><p>首先我们可以确定，<code>Point</code>这个东西是我们自己定义的，所以显然这两个带Point的函数也不可能是由<code>polyglot.h</code>提供的。那么为什么在我们也没有定义这两个函数的情况下这段程序可以正常编译呢？这就要靠神奇的(<em>FUCKING UNREADABLE</em>)宏来实现了。</p><p>按照国际惯例(幸好你们还有个国际惯例)宏是全部大写的，所以<code>POLYGLOT_DECLARE_STRUCT</code>就一定是个宏了。于是我在<code>polyglot.h</code>的最底下找到了关于这个的定义。</p><pre><code class="C">#define POLYGLOT_DECLARE_STRUCT(type) __POLYGLOT_DECLARE_GENERIC_TYPE(struct type, type)#define __POLYGLOT_DECLARE_GENERIC_TYPE(typedecl, typename)                                                                                          \  __POLYGLOT_DECLARE_GENERIC_ARRAY(typedecl, typename)                                                                                               \                                                                                                                                                     \  __attribute__((always_inline)) static inline typedecl *polyglot_as_##typename(void *p) {                                                           \    void *ret = polyglot_as_typed(p, polyglot_##typename##_typeid());                                                                                \    return (typedecl *)ret;                                                                                                                          \  }                                                                                                                                                  \                                                                                                                                                     \  __attribute__((always_inline)) static inline void *polyglot_from_##typename(typedecl * s) {                                                        \    return polyglot_from_typed(s, polyglot_##typename##_typeid());                                                                                   \  }  #define __POLYGLOT_DECLARE_GENERIC_ARRAY(typedecl, typename)                                                                                         \  __attribute__((always_inline)) static inline polyglot_typeid polyglot_##typename##_typeid() {                                                      \    static typedecl __polyglot_typeid_##typename[0];                                                                                                 \    return __polyglot_as_typeid(__polyglot_typeid_##typename);                                                                                       \  }                                                                                                                                                  \                                                                                                                                                     \  __attribute__((always_inline)) static inline typedecl *polyglot_as_##typename##_array(void *p) {                                                   \    void *ret = polyglot_as_typed(p, polyglot_array_typeid(polyglot_##typename##_typeid(), 0));                                                      \    return (typedecl *)ret;                                                                                                                          \  }                                                                                                                                                  \                                                                                                                                                     \  __attribute__((always_inline)) static inline void *polyglot_from_##typename##_array(typedecl *arr, uint64_t len) {                                 \    return polyglot_from_typed(arr, polyglot_array_typeid(polyglot_##typename##_typeid(), len));                                                     \  }</code></pre><p>最后发现<code>POLYGLOT_DECLARE_STRUCT(Point)</code>的<code>Point</code>就是宏里的<code>typename</code>。这就破案了，这段宏为我们定义了<code>polyglot_from_##typename</code>和<code>polyglot_from_##typename##_array</code>这两个方法，而其中的<code>typename</code>在编译期就被<code>Point</code>替换掉了（我看你是在为难我IDE）。</p><h2 id="骚气满满的EventBus"><a href="#骚气满满的EventBus" class="headerlink" title="骚气满满的EventBus"></a>骚气满满的EventBus</h2><p>上一个还是很容易理解的，毕竟只是使用了<code>##var</code>这么个特性罢了。不知道的时候觉得很神奇，知道了之后也就是这么一回事。而接下来这个是让我着实惊讶了许久。<br>先看一段代码</p><pre><code class="C++">/* * Class:     com_sun_glass_ui_win_WinWindow * Method:    _setView * Signature: (JJ)Z */JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_win_WinWindow__1setView    (JNIEnv * env, jobject jThis, jlong ptr, jobject view){    ENTER_MAIN_THREAD()    {        GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);        if (activeTouchWindow == hWnd) {            activeTouchWindow = 0;        }        pWindow-&gt;ResetMouseTracking(hWnd);        pWindow-&gt;SetGlassView(view);        // The condition below may be restricted to WS_POPUP windows        if (::IsWindowVisible(hWnd)) {            pWindow-&gt;NotifyViewSize(hWnd);        }    }    GlassView * view;    LEAVE_MAIN_THREAD_WITH_hWnd;    ARG(view) = view == NULL ? NULL : (GlassView*)env-&gt;GetLongField(view, javaIDs.View.ptr);    PERFORM();    return JNI_TRUE;}</code></pre><p>做过安卓的朋友肯定很熟悉这个套路，修改UI的事情只能在UI线程里做，而对于大部分程序来说UI线程就是主线程，所以这里的<code>ENTER_MAIN_THREAD</code>看着也很正常。</p><p>但是问题来了，这个乍一看很正常的程序，仔细想想怎么都不对劲啊。参数里传进来了一个<code>view</code>，为什么下面还能再声明一个？这个看着很像是函数体的<code>ENTER_MAIN_THREAD()</code>里面的那个<code>hWnd</code>是哪里跑出来的？最底下的<code>ARG</code>和<code>PERFORM</code>这两个又是干嘛的？</p><p>当我第一次意识到这些问题的时候，我甚至开始怀疑这是不是C++的新特性，C++式fp难道是长这个样子的。</p><p>在深入♂了解了之后，我才发现，都是假的。这种漂亮的代码都是假的，是特技，这个世界上根本就没有这种代码。所以现在让我们来看看它是怎么实现的。<br>首先是<code>ENTER_MAIN_THREAD</code>，既然有国际惯例在，那这个东西想必是个宏了</p><pre><code class="C++">#define ENTER_MAIN_THREAD() \    class _MyAction : public Action {    \        public: \                virtual void Do()</code></pre><p>这tm就是它的定义。你可能会说，这tm括号都没闭合呢！是啊，所以它还有下半个，<code>LEAVE_MAIN_THREAD_WITH_hWnd</code></p><pre><code class="C++">#define LEAVE_MAIN_THREAD_WITH_hWnd  \    HWND hWnd;  \     } _action;  \    ARG(hWnd) = (HWND)ptr;</code></pre><p>万万没想到，这几天otto上当了，我也上当了。所以这部分真实情况是长这个样子的</p><pre><code class="C++">class _MyAction:public Action {    public:        virtual void Do()         {            GlassWindow *pWindow = GlassWindow::FromHandle(hWnd);            if (activeTouchWindow == hWnd) {                activeTouchWindow = 0;            }            pWindow-&gt;ResetMouseTracking(hWnd);            pWindow-&gt;SetGlassView(view);            // The condition below may be restricted to WS_POPUP windows            if (::IsWindowVisible(hWnd)) {                pWindow-&gt;NotifyViewSize(hWnd);        }    }    HWND hWnd;    GlassView * view;} _action;ARG(hWnd) = (HWND)ptr;ARG(view) = view == NULL ? NULL : (GlassView*); PERFORM();</code></pre><p>行吧，你还真是<code>Runnable</code>转世到了C++上啊。借着一手宏定义给我整成了lambda的样子。</p><p>到了这里，就只有<code>ARG</code>和<code>PERFORM()</code>还没有解释清楚了。让我们来看看它们两个的定义。</p><pre><code class="C++">#define ARG(var) _action.var#define PERFORM() GlassApplication::ExecAction(&amp;_action)</code></pre><p>于是，最底下这部分就变成了</p><pre><code class="C++">_action.hWnd = (HWND)ptr;_action.view =  view == NULL ? NULL : (GlassView*);GlassApplication::ExecAction(&amp;_action);</code></pre><p>顺便一提，<code>GlassApplication::ExecAction</code>是这样的</p><pre><code class="C++">void GlassApplication::ExecAction(Action *action){    if (!pInstance) {        return;    }    ::SendMessage(pInstance-&gt;GetHWND(), WM_DO_ACTION, (WPARAM)action, (LPARAM)0);}</code></pre><p>搞过Win32编程的朋友一定很熟悉这个东西，没搞过的话理解成在EventBus上发送消息就行了。</p><p>所以到了最后，这个看着像是线程切换的操作只是把<code>_action</code>发送给了主线程而已。高，真的是高。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>宏这个东西真是写者爽翻天，看者流眼泪。这么一想，好像刚开始写C++的时候就有用宏会影响代码可读性这么一说。只是这几年接触C++的少，没见过什么市面，把宏想的太简单了。如今见过这种骚操作之后，我想说，<em>加入光荣的进化吧</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这几天一直在搞Javafx和Graalvm。主要是Graalvm在Windows上编译native image问题太tm多了。主要问题都出在
      
    
    </summary>
    
    
      <category term="C++" scheme="http://wooyme.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Graalvm native-image JavaFx初体验</title>
    <link href="http://wooyme.github.io/2019/06/04/Graalvm%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://wooyme.github.io/2019/06/04/Graalvm初体验/</id>
    <published>2019-06-04T11:08:17.000Z</published>
    <updated>2019-07-26T12:58:29.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尝试了一段时间的Go，发现一是还是舍不得Kotlin，二是Go的UI库实在有点蛋疼，所以最近还是寻找了一些重返Kotlin的解决方案。Graalvm我早有耳闻，也有过一次不愉快的尝试，但是看到它的版本号在今年脱离了RC的标志来到了19.1.1，我决定还是再给它一个机会。</p><h1 id="Graalvm"><a href="#Graalvm" class="headerlink" title="Graalvm"></a>Graalvm</h1><blockquote><p>官网地址: <a href="https://www.graalvm.org/" target="_blank" rel="noopener">https://www.graalvm.org/</a></p></blockquote><p>还是稍微介绍一下<em>Graalvm</em>吧。就目前看来Graalvm算是近年来Oracle最有创造力的产品了。</p><blockquote><p>GraalVM is a universal virtual machine for running applications written in JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala, Groovy, Kotlin, Clojure, and LLVM-based languages such as C and C++.<br>GraalVM removes the isolation between programming languages and enables interoperability in a shared runtime. It can run either standalone or in the context of OpenJDK, Node.js or Oracle Database.</p></blockquote><blockquote><p>Graalvm是一款通用虚拟机，可以运行由Javascript，Python，Ruby，R和基于JVM(Java,Kotlin,Scala,Groovy)以及基于LLVM(C和C++)的语言开发的程序。GraalVM去除了语言之间的隔阂，并且允许它们在运行过程中保持互通。GraalVm既可以独立运行，也可以在OpenJDk，NodeJs或者Oracle数据库的环境中运行(这句话，不明所以)。</p></blockquote><p>以及一些特性</p><ul><li>Polyglot(通用性)<blockquote><p>Zero overhead interoperability between programming languages allows you to write polyglot applications and select the best language for your task.<br>不同语言间无痛交互，根据业务情况任意选择语言</p></blockquote></li><li>Native(原生,这是重点)<blockquote><p>Native images compiled with GraalVM ahead-of-time improve the startup time and reduce the memory footprint of JVM-based applications.<br>GraalVM生成的Native image(可以认为就是可执行文件) 使用AOT技术加快启动时间并且减少基于JVM的应用的启动内存(Java系客户端的两大痛处)</p></blockquote></li><li>Embeddable(嵌入式，不是单片机那个)<blockquote><p>GraalVM can be embedded in both managed and native applications. There are existing integrations into OpenJDK, Node.js and Oracle Database<br>这个Embeddable的特性我还没有接触过，所以并不理解它所说的与OpenJDK这些一起运行是个什么意思</p></blockquote></li></ul><p>GraalVM的这么多特性，对于我来说，最有价值的就是Native了。相信对于大部分Java系的开发者来说也是如此，“我Java系的生态要啥有啥，还要其他语言干嘛？”<br>所以接下来就写一下GraalVM这个不成熟到能跟Kotlin Native 55开的Native image吧。</p><h1 id="Native-image"><a href="#Native-image" class="headerlink" title="Native image"></a>Native image</h1><blockquote><p>官方文档 <a href="https://www.graalvm.org/docs/reference-manual/aot-compilation" target="_blank" rel="noopener">https://www.graalvm.org/docs/reference-manual/aot-compilation</a></p></blockquote><p>话是说的很漂亮，解决了Java写客户端的两大痛处，但是实际用起来那可真全是痛处。当然这里说的痛处是开发中的痛处，在成功build了native image之后，确实是如官网所说，启动速度快，内存占用小(除了莫名其妙的申请了32G虚拟内存)。</p><p>首先一点是，在19.0之后，native-image不再包含在Graal的基础包中了，要安装的话，需要运行个命令</p><blockquote><p>gu install native-image</p></blockquote><p> Linux上这个操作可能需要sudo。文件是从gtihub上下载的，所以国内下载可能会很慢，官网上表示可以配置代理，但是我好像不太成功。总归等了挺久之后也算是下载下来了。</p><p>目前Native image还有很多的限制。按照github上的官方文档，Native image对一些Java的特性还不能支持</p><table><thead><tr><th>特性</th><th>支持情况</th></tr></thead><tbody><tr><td>动态类加载</td><td>不支持</td></tr><tr><td>反射</td><td>需要配置文件</td></tr><tr><td>动态代理</td><td>需要配置文件</td></tr><tr><td>JNI</td><td>大多数支持</td></tr><tr><td>Unsafe Memory Access</td><td>大多数支持</td></tr><tr><td>类初始化(static里初始化类)</td><td>支持</td></tr><tr><td>InvokeDynamic</td><td>不支持</td></tr><tr><td>Lambda Expressions</td><td>支持(有问题)</td></tr><tr><td>Synchronized, wait, and notify</td><td>支持</td></tr><tr><td>Finalizers</td><td>不支持</td></tr><tr><td>References</td><td>大多数支持</td></tr><tr><td>Threads</td><td>支持</td></tr><tr><td>Identity Hash Code</td><td>支持</td></tr><tr><td>Security Manager</td><td>不支持</td></tr><tr><td>JVMTI, JMX, other native VM interfaces</td><td>不支持</td></tr><tr><td>JCA Security Services</td><td>支持</td></tr></tbody></table><p>首先动态类加载肯定是不用想了，native的部分与非native的部分明显不能建立联系。而反射可以通过传入配置文件来获得支持，这就让许多框架的使用成为了可能。</p><h1 id="Native的客户端"><a href="#Native的客户端" class="headerlink" title="Native的客户端"></a>Native的客户端</h1><p>如果只是一个简单的，单线程的console应用，那么native image的使用基本上是不会有任何问题。但是一旦涉及了GUI，这个native image就有点搞人心态了。 </p><p>Java上大家熟知的GUI方案无外乎Swing和Javafx，在graal的issues中可以看到现在尚且不能支持swing，而且由于swing已经是个如此年迈的框架，我也不倾向于使用它。那么现在的选择就只有javafx了。</p><h2 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h2><p>GraalVM有两个版本，一个CE，一个EE，其中CE版是不带JavaFx的。而EE中所带的JavaFx会在编译成native image的过程中出现无数的问题，于是我搜索了graal的issues，并且成功找到了一些前人的经验</p><blockquote><p><a href="https://github.com/oracle/graal/issues/403" target="_blank" rel="noopener">https://github.com/oracle/graal/issues/403</a></p><p><a href="https://github.com/oracle/graal/issues/994" target="_blank" rel="noopener">https://github.com/oracle/graal/issues/994</a></p></blockquote><p><em>其中issue403是Glavo大佬提出的</em></p><p><strong>在 403 的评论中可以看到一个叫做gluonhq的产品</strong>，</p><blockquote><p> <a href="https://github.com/gluonhq/client-samples" target="_blank" rel="noopener">https://github.com/gluonhq/client-samples</a></p></blockquote><p>应该有人通过它成功编译了javafx的native image。我也按照gluonhq的文档做了一些尝试，非常遗憾的是，我并没有成功，失败的原因也不是说出现了什么错误，而是这货占用的内存量有点夸张。几次尝试编译都因为内存不足而告终，后来我曾试图把开发环境搬到生产服务器上(一台16核32G的虚拟服务器)，但最终因为gluonhq不支持windows而宣告失败。所以如果看到这篇文章的人中有不用Windows且内存达到16G的话，可以尝试一下直接使用gluonhq client。</p><p>虽然用gluonhq失败了，但是至少说明已经有人成功了吧。于是我在994中的最后一条评论里找到了这个仓库</p><blockquote><p><a href="https://github.com/maxum2610/HelloJFX-GraalSVM" target="_blank" rel="noopener">https://github.com/maxum2610/HelloJFX-GraalSVM</a></p></blockquote><p>maxum2610表示要构建naive image需要自己build一个OpenJFX。这简直是打开了新世界的大门。既然都自己构建OpenJFX了，那稍微改改代码总也不是什么大事吧。于是参考maxum2610的文档，我开始了自己的旅程。</p><h2 id="OpenJFX"><a href="#OpenJFX" class="headerlink" title="OpenJFX"></a>OpenJFX</h2><p>build OpenJFX的过程中只有遇到了一个问题，这货要求gradle的版本是1.8，然后IDEA默认的是5.1，所以要自己调整一下。</p><p>整个构建的过程是很愉快的，把构建得到的<code>/build/sdk/rt/lib</code>里的文件复制到Graalvm的jre下就可以得到一个自己的JavaFx环境了。接着我开始尝试编译Native image,并且不出意外的失败了。</p><p>报的错误是issue1376中的错误</p><blockquote><p><a href="https://github.com/oracle/graal/issues/1376" target="_blank" rel="noopener">https://github.com/oracle/graal/issues/1376</a></p><p>Invoke with MethodHandle argument could not be reduced to at most a single call: java.lang.invoke.MethodHandleImpl.buildVarargsArray(MethodHandle, MethodHandle, int)</p></blockquote><p>解决方案是把所有报这个错的地方的lambda全部改成java6的语法。</p><p>在全部改完之后就可以成功生成naive image了。当然走到了这步还没有成功。<br>在运行的过程中会发现加载libglass.so失败的问题，一开始我以为是路径有问题，后来发现是在调用JNI_Onload的时候返回了-1。</p><p>于是本着既然都改了源码了，再改点C的代码又怎么样呢的想法，大概看了一下glass_general.cpp中JNI_Onload函数的内容，发现是在加载<code>sun/misc/GThreadHelper</code>的时候报错了，</p><pre><code class="C++">   clazz = env-&gt;FindClass(&quot;sun/misc/GThreadHelper&quot;);   if (env-&gt;ExceptionCheck()) return JNI_ERR;   if (clazz) {       jmethodID mid_getAndSetInitializationNeededFlag = env-&gt;GetStaticMethodID(clazz, &quot;getAndSetInitializationNeededFlag&quot;, &quot;()Z&quot;);       if (env-&gt;ExceptionCheck()) return JNI_ERR;       jmethodID mid_lock = env-&gt;GetStaticMethodID(clazz, &quot;lock&quot;, &quot;()V&quot;);       if (env-&gt;ExceptionCheck()) return JNI_ERR;       jmethodID mid_unlock = env-&gt;GetStaticMethodID(clazz, &quot;unlock&quot;, &quot;()V&quot;);       if (env-&gt;ExceptionCheck()) return JNI_ERR;       env-&gt;CallStaticVoidMethod(clazz, mid_lock);       if (!env-&gt;CallStaticBooleanMethod(clazz, mid_getAndSetInitializationNeededFlag)) {           init_threads();       }       env-&gt;CallStaticVoidMethod(clazz, mid_unlock);   } else {        env-&gt;ExceptionClear();        init_threads();   }</code></pre><p>确认了一下jniconfig，发现确实没有这个库。在搜索了一圈之后决定干脆不加载了，直接走else分支。成功！</p><p>我修改的OpenJFX已经传到github上了</p><blockquote><p> <a href="https://github.com/Wooyme/openjdk-jfx" target="_blank" rel="noopener">https://github.com/Wooyme/openjdk-jfx</a></p></blockquote><p>重新build OpenJFX之后编译出的naive image就可以正常运行了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Graalvm依然是个很不成熟的技术，要尝试的话就得做好踩坑的觉悟。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;尝试了一段时间的Go，发现一是还是舍不得Kotlin，二是Go的UI库实在有点蛋疼，所以最近还是寻找了一些重返Kotlin的解决方案。Gra
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WSocks疯牛病版技术内幕</title>
    <link href="http://wooyme.github.io/2019/04/24/WSocks%E7%96%AF%E7%89%9B%E7%97%85%E7%89%88%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>http://wooyme.github.io/2019/04/24/WSocks疯牛病版技术内幕/</id>
    <published>2019-04-24T12:47:48.000Z</published>
    <updated>2019-04-24T14:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><blockquote><p><a href="https://github.com/Wooyme/Wsocks" target="_blank" rel="noopener">https://github.com/Wooyme/Wsocks</a><br>kcp-raw分支</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在LowEndBox上看到一个非常非常便宜的VPS，一年8刀。借着50块买不了吃亏，买不了上当的想法，就随手买了一年。当然，这个机器确实非常垃圾。不过这也很正常，OpenVZ的低价VPS肯定是超售的，而这样便宜的机器要是没有问题才是真的有问题。<br>最开始，我尝试在上面装了一下WSocks2.0，然后发现速度只有几k，基本上就是打开个网页都卡的水平，而且因为是openvz(最坑的是说好的SolusVM到了最后也不知所踪)所以bbr和锐速都上不了，本来是打算就此作罢了。但是无意中看到了几篇关于bbr原理的文章，然后几经周折，被打开了新世界的大门。</p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>装过bbr或者锐速的朋友肯定体验过这两个补丁近乎开挂的速度。尤其是锐速，凭借其更加流氓的算法，能几乎把带宽跑满。那么为什么使用了这些模块之后能让速度更快呢？ 这就要谈到TCP的拥塞控制了。</p><blockquote><p>源自简书 <a href="https://www.jianshu.com/p/97e5d7e73ba0" target="_blank" rel="noopener">https://www.jianshu.com/p/97e5d7e73ba0</a></p></blockquote><blockquote><p>拥塞控制就是防止过多的数据注入到网络中，这样可以防止网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p></blockquote><p>那么防止链路过载的方式主要有两种，一是 <strong>慢开始</strong>， 二是 <strong>拥塞避免</strong></p><ul><li>慢开始<blockquote><p>慢开始算法中的主要方法就是有小到大逐渐增大发送窗口。<br>举个例子：首先，发送方设置cwnd=1（为方便理解，这里用报文段的个数作为窗口大小的单位），在收到接收方发来的确认后（也就是下个传输轮次），设置cwnd=2，然后将发送窗口的数据发送出去。在一次收到接收方发来的确认后，发送方设置cwnd=4，再讲发送窗口中的数据发送出去。然后再重复上面的过程。</p></blockquote></li><li>拥塞避免<blockquote><p>TCP/IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小（不能小于2）。</p></blockquote></li></ul><p>主要的问题在于拥塞避免阶段，常用的拥塞避免算法中，一旦发现超时，窗口大小就会下降的非常快，并且之后上升的速度也会非常慢，于是传输速度就很垃圾了。<br>而bbr和锐速都是修改了这部分算法，让窗口保持在比较大的阶段。当然这种行为本质是流氓行为，不然在Linux 4.10之后的内核中也不会默认关闭bbr。当只有少数人使用的时候，网速会得到非常高的提升，但是一旦大家都用了这种算法，效果也就会趋于平庸了。</p><h1 id="更无耻的UDP"><a href="#更无耻的UDP" class="headerlink" title="更无耻的UDP"></a>更无耻的UDP</h1><p>可是我们的OpenVZ并不能安装bbr或锐速。于是从内核层面修改算法就显得不太现实了。但是除了TCP之外，我们还有一个更加简单的协议可以选择————UDP。<br>UDP是真的很简单，没有流控、没有拥塞控制、也不管数据是否真的传达到了。一旦用了UDP，只管发就是了。当然，简单的背后就是各种的不可靠，无论是丢包或是到达顺序错误都会导致上层出错，这显然是我们不想看到的。于是Google了许久，找到了一个国人开发的UDP Base协议——KCP。</p><blockquote><p>KCP <a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a></p></blockquote><p>KCP为UDP添加了类似连接的机制，包括连接标识符，ack，窗口，缓冲区等。它让UDP成为了可靠的传输协议。而且由于这些东西都是KCP添加的，所以都不受制于内核，完全可以自己调节。作者就为我们提供了 “极速模式”,实测效果确实很给力，通过开启快速重传、关闭流量控制、调大发送接收窗口，减小mtu，基本可以把服务器带宽压榨干净，而且延迟也确实降低了很多。</p><h1 id="比UDP更无耻"><a href="#比UDP更无耻" class="headerlink" title="比UDP更无耻"></a>比UDP更无耻</h1><p>在实际测试中发现，虽然KCP能达到锐速之类的效果，但是有时候因为ISP的干扰，UDP报文可能会被丢弃。毕竟因为TCP有阻塞控制，把资源分配给TCP会更加合理一些。但是我们既然都已经这么流氓了，再流氓点又如何呢。<br>TCP和UDP在报文上的区别仅仅是报头有些不同，我们完全可以用原始套接字(Raw Socket)自己构造一个TCP报头。这里不得不吹一下KCP的作者，简直就是天才。KCP虽然是以 “Reliable UDP”自诩，但是实际上KCP下层完全可以接任何协议，所以接一个畸形的TCP也是完全没问题的。<br>在KCP的output中，我取了udp2raw_tunnel的部分代码</p><blockquote><p><a href="https://github.com/wangyu-/udp2raw-tunnel" target="_blank" rel="noopener">https://github.com/wangyu-/udp2raw-tunnel</a></p></blockquote><p>让KCP发送的数据变成披着TCP外皮的UDP包。现在只要解决接收的部分，就可以完成客户端与服务端的通信了。这里唯一的问题就是，这种畸形的TCP包，普通的TCP服务端是接收不到的。所以我加入了PCAP</p><blockquote><p>PCAP的java封装 <a href="https://github.com/kaitoy/pcap4j" target="_blank" rel="noopener">https://github.com/kaitoy/pcap4j</a></p></blockquote><p>用于捕获所有从远程服务器的规定端口发送的数据，再把这些数据作为KCP的input传输进去。至此一个基于Raw Socket的KCP协议就完成了。</p><h1 id="Option（伪造IP）"><a href="#Option（伪造IP）" class="headerlink" title="Option（伪造IP）"></a>Option（伪造IP）</h1><p>这里加个题外话。其实也不是题外话，在WSocks的kcp分支里，我实现了一个伪造IP发送UDP包的功能。该功能总的来说就是让服务端用真实的IP接收客户端请求，再从另一个IP发送返回的数据。以前做过一些伪造IP的实验，但都失败了，因为在实际的网络中，各种路由器、网关会检测这个IP是否属于自己包含的范围，如果不是这个包就会被丢掉。所以在公网上想要假装自己是某台机器其实是不现实的。但是如果换一个思路，我们并不需要假装自己是谁，我们只需要让自己不是自己就行了。于是我重新做了些测试，发现在一定范围内，修改IP完全是可行的。在我一台加利福尼亚的VPS上，可供选择的IP多达65535个。通过这种IP伪装的方式，一定程度上也可以保护服务器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是WSocks疯牛病版的一些原理，总的来说就是一个逐渐突破下限的过程。既然想要空手套白狼，那只有比无耻更无耻了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Wooyme/Wsocks&quot; target
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://wooyme.github.io/tags/C-C/"/>
    
      <category term="Vert.x" scheme="http://wooyme.github.io/tags/Vert-x/"/>
    
      <category term="Kotlin" scheme="http://wooyme.github.io/tags/Kotlin/"/>
    
      <category term="网络协议" scheme="http://wooyme.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Angular下的Bootstrap Modal</title>
    <link href="http://wooyme.github.io/2019/02/18/Angular%E4%B8%8B%E7%9A%84Bootstrap-Modal/"/>
    <id>http://wooyme.github.io/2019/02/18/Angular下的Bootstrap-Modal/</id>
    <published>2019-02-18T08:27:10.000Z</published>
    <updated>2019-02-18T09:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Bootstrap有一个Angular的版本——ngx-bootstrap，里面是有提供Boostrap Modal的，但是我一直觉得这种Modal的形式不太好。因为Modal本来就是相对独立在页面之外的，如果要把Modal的代码也写到当前页面里的话其实反而破坏了页面本身的结构。所以我自己封装了一个Modal，写这篇博客记录一下封装的过程。</p><h1 id="Modal-Component"><a href="#Modal-Component" class="headerlink" title="Modal Component"></a>Modal Component</h1><p>不管Modal的html部分写在什么地方，Component都是必需的。</p><pre><code class="html">  &lt;div (click)=&quot;onContainerClicked($event)&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; [ngClass]=&quot;{&#39;in&#39;: visibleAnimate}&quot;       [ngStyle]=&quot;{&#39;display&#39;: visible ? &#39;block&#39; : &#39;none&#39;, &#39;opacity&#39;: visibleAnimate ? 1 : 0}&quot;&gt;    &lt;div class=&quot;modal-dialog&quot;&gt;      &lt;div class=&quot;modal-content&quot;&gt;        &lt;ng-template modal-host&gt;&lt;/ng-template&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><p>template的部分非常简单。因为我希望Modal的主体是可以自定义的，所以就在里面使用了<code>ng-template</code>标签。</p><pre><code class="Typescript">@Directive({  selector: &#39;[modal-host]&#39;,})export class ModalDirective {  constructor(public viewContainerRef: ViewContainerRef) { }}</code></pre><p>modal-host对应的就是这段代码。<br>接下来就是Modal Component的主体部分了</p><pre><code class="Typescript">export class ModalComponent{  public visible = false;  public visibleAnimate = false;  @ViewChild(ModalDirective) modalHost:ModalDirective;  constructor(private componentFactoryResolver: ComponentFactoryResolver,private modal:ModalService){    this.modal.show.subscribe(value =&gt; {      this.show(value);    })  }  public show(item:ShowItem): void {    //用工厂从component类型里生成component    let componentFactory = this.componentFactoryResolver.resolveComponentFactory(item.component);    let viewContainerRef = this.modalHost.viewContainerRef;    viewContainerRef.clear();    let componentRef = viewContainerRef.createComponent(componentFactory);    (&lt;ModalValue&gt;componentRef.instance).callback = item.callback;    (&lt;ModalValue&gt;componentRef.instance).params = item.params;    let modal = this;    (&lt;ModalValue&gt;componentRef.instance).close = ()=&gt;{modal.hide()};    (&lt;ModalValue&gt;componentRef.instance).onInit();    this.visible = true;    setTimeout(() =&gt; this.visibleAnimate = true, 100);  }  public hide(): void {    this.visibleAnimate = false;    setTimeout(() =&gt; this.visible = false, 300);  }  public onContainerClicked(event: MouseEvent): void {    if ((&lt;HTMLElement&gt;event.target).classList.contains(&#39;modal&#39;)) {      this.hide();    }  }}export interface ModalValue {  callback:(any)=&gt;void;  close:()=&gt;void;  params:any;  onInit();}export class ShowItem{  component:Type&lt;ModalValue&gt;;  callback:(any)=&gt;void;  params:any;  constructor(item:Type&lt;any&gt;,params:any,callback:(any)=&gt;void){    this.component = item;    this.callback = callback;    this.params = params;  }}</code></pre><p>关键部分在<code>show</code>方法里。当从Modal Service(后面会写)里拿到<code>item</code>之后就会调用<code>show</code>方法。首先是拿到新的component，清除之前的component，接着把<code>params</code>，<code>callback</code>注入到component中，调用<code>onInit</code>方法。最后显示Modal。</p><p>Component写完之后需要在app.component.html里给它腾个位置，不然没地方显示。</p><h1 id="Modal-Service"><a href="#Modal-Service" class="headerlink" title="Modal Service"></a>Modal Service</h1><pre><code class="Typescript">@Injectable({  providedIn: &#39;root&#39;})export class ModalService {  show: Observable&lt;ShowItem&gt;;  private showIn: Subject&lt;ShowItem&gt;;  constructor() {    this.showIn = new Subject&lt;ShowItem&gt;();    this.show = this.showIn.asObservable();  }  modal(component:Type&lt;any&gt;,params:any):Promise&lt;any&gt;{    return new Promise((resolve) =&gt; {      this.showIn.next(new ShowItem(component, params, resolve));    })  }}</code></pre><p>Modal Service部分就非常简单了。创建一个<code>Obervable</code>给Modal Component订阅。每当其他地方调用<code>modal</code>方法的时候就会把component类型和参数发布出去。</p><h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><p>以一个非常简单的登出提示框为例</p><pre><code class="Typescript">@Component({  template: `    &lt;div class=&quot;modal-header&quot;&gt;      登出确认    &lt;/div&gt;    &lt;div class=&quot;modal-body&quot;&gt;      &lt;p&gt;是否要退出当前账号&lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;modal-footer&quot;&gt;      &lt;button class=&quot;btn btn-primary&quot; (click)=&quot;finish()&quot;&gt;确定&lt;/button&gt;    &lt;/div&gt;  `})export class LogoutEnsure implements ModalValue {  @Input() callback: (any) =&gt; void;  @Input() close: () =&gt; void;  @Input() params: any;  onInit() {  }  finish() {    this.callback({});    this.close();  }}....  logout() {    this.modal.modal(LogoutEnsure, {}).then(() =&gt; {      this.api.getLogout().subscribe(()=&gt;{        this.router.navigate([&#39;/&#39;]);      });    });  }....</code></pre><p>Component只要继承<code>ModalValue</code>就可以在Modal中显示出来。调用modal的时候只要传Component类型即可。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>自己实现一个Modal还是非常简单的。这样可以避免像ngx-bootstrap一样dom节点过深，而且代码结构也更加美观。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Bootstrap有一个Angular的版本——ngx-bootstrap，里面是有提供Boostrap Modal的，但是我一直觉得这种M
      
    
    </summary>
    
    
      <category term="Angular" scheme="http://wooyme.github.io/tags/Angular/"/>
    
      <category term="Typescript" scheme="http://wooyme.github.io/tags/Typescript/"/>
    
      <category term="前端" scheme="http://wooyme.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>川叔的Ubuntu私房菜（2333</title>
    <link href="http://wooyme.github.io/2019/02/12/%E5%B7%9D%E5%8F%94%E7%9A%84Ubuntu%E7%A7%81%E6%88%BF%E8%8F%9C%EF%BC%882333/"/>
    <id>http://wooyme.github.io/2019/02/12/川叔的Ubuntu私房菜（2333/</id>
    <published>2019-02-12T07:04:45.000Z</published>
    <updated>2020-01-20T13:35:57.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本篇针对Ubuntu18.04或Ubuntu Gnome</strong><br>推荐一本书《鸟哥的Linux私房菜》，虽然我没有看完，但真的是一本很棒的书。由于鸟哥的Linux写的非常深入，所以对于不做运维的人来说有些太难了。<br>这篇《川叔的Ubuntu私房菜》就作为我记录各种在使用Ubuntu时学到的小技巧的地方。<strong>顺便一提利根川赛高</strong>。</p><h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>linux的开机自启动方式很多，去搜索的话一般的建议都是添加到服务里。但是有时候我们就一个简单的脚本添加到服务也太麻烦了。所以我找到了一种我认为最简单的开机启动方法。</p><pre><code class="bash">crontab -e</code></pre><p>如果你的系统里有多种编辑器的话，会进入一个编辑器选择的步骤<br>然后在打开的文本里添加</p><pre><code>@reboot your_command</code></pre><p>这样下次启动的时候就会执行这个命令，路径什么的需要注意一下。<br>除了<code>@reboot</code>之外，还有个服务器上非常常用的<code>@daily</code>，即每天自动执行，当然<code>crontab</code>还有很多其他的定时任务。有兴趣的可以看这个</p><blockquote><p><a href="http://man7.org/linux/man-pages/man5/crontab.5.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man5/crontab.5.html</a></p></blockquote><h1 id="SCP-不是基金会"><a href="#SCP-不是基金会" class="headerlink" title="SCP (不是基金会)"></a>SCP (不是基金会)</h1><blockquote><p>Linux之间传文件有除了ftp外更简单的方式</p></blockquote><p>不知道为什么，每次在服务器上装vsftpd都是一件非常痛苦的事情，总会遇到各种奇奇怪怪的问题。以至于后来有一段时间，我甚至选择使用网盘、github这种第三方存储作为上传文件到服务器的媒介。<br>这种情况终止于一天逛<strong>Ubuntu Forums</strong>的时候发现有人用</p><pre><code class="bash">scp xxx root@xxx:/home/xxx</code></pre><p>的命令。查了一下才知道，这就是基于ssh的文件上传。</p><pre><code>usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]           [-l limit] [-o ssh_option] [-P port] [-S program]           [[user@]host1:]file1 ... [[user@]host2:]file2</code></pre><p>example</p><pre><code class="bash">scp this.zip root@my.server.com:/home/www/this.zip</code></pre><p>要注意的是目录需要提前建好，不然会报<em>没有找到目录或文件</em>的错。</p><h1 id="kill-9-PID-amp-xkill"><a href="#kill-9-PID-amp-xkill" class="headerlink" title="kill -9 PID &amp; xkill"></a>kill -9 PID &amp; xkill</h1><p>有时会遇到执行了<code>kill PID</code>但是进程还是杀不死的情况。这个时候加上<code>-9</code>参数就可以杀死进程了。<br>另外在桌面端的时候有时候会遇到Chrome、QQ、LibreOffice卡死的情况，这个时候可以<code>Ctrl+Alt+T</code>打开终端输入<code>xkill</code>,然后鼠标就会变成一个”x”，点一下卡死的窗口就可以关掉了。顺便一提的是有时候Ubuntu会弹出系统崩溃、系统错误这样的对话框，实际上其中只有很小一部分是真正的系统崩溃，大部分都是某个软件崩溃了，具体内容可以展开详情看看。</p><h1 id="QQ-amp-TIM"><a href="#QQ-amp-TIM" class="headerlink" title="QQ &amp; TIM"></a>QQ &amp; TIM</h1><p>由于腾讯压根就没有提供Linux的版本所以在Ubuntu上用QQ是一个比较麻烦的事情。Github上有很多QQ for Linux的项目，但是其实最终都指向了一个唯一的解决方案——<code>Wine</code>。  </p><blockquote><p>说个冷知识，<code>Wine</code>的全称是<code>Wine Is Not an Emulator</code></p></blockquote><p>Wine给在Linux、Mac上运行Windows程序提供了可能。虽然各种奇怪的bug和内存泄露是经常的事，但是有总比没有好。不过呢如果真的要从安装Wine、安装各种.Net库、字体开始到最终安装QQ、TIM，那也太麻烦了。比较简单的是去Github上找已经打成<code>AppImage</code>的发行版，但是还有一种更通用、更稳定的方法——<code>Crossover</code>。</p><p><code>Crossover</code>是一款商业软件、所以是收费的，终身是100多，不想付的话网上也应该能找到破解版。</p><blockquote><p>官网 <a href="http://www.crossoverchina.com/goumai.html?lid=1984" target="_blank" rel="noopener">http://www.crossoverchina.com/goumai.html?lid=1984</a></p></blockquote><p>装了<code>Crossover</code>之后安装Windows上的程序就完全傻瓜化了，而且会有各种软件在Linux上兼容性的评分。QQ和TIM间建议安装TIM，QQ有时候会突然崩溃，比较僵硬。</p><h1 id="系统监视器-任务管理器"><a href="#系统监视器-任务管理器" class="headerlink" title="系统监视器(任务管理器)"></a>系统监视器(任务管理器)</h1><p>Ubuntu是有个类似于任务管理器的东西的，只不过Gnome并没有为他绑定快捷键，如果想要像Windows一样使用任务管理器的话需要在<code>设置</code>-&gt;<code>设备</code>-&gt;<code>键盘</code>里添加。系统监视器对应的命令是<code>gnome-system-monitor</code></p><h1 id="美化桌面"><a href="#美化桌面" class="headerlink" title="美化桌面"></a>美化桌面</h1><p>虽然18.04换了Gnome，但是完完全全的继承了原本Unity的丑。看看隔壁<code>Kali</code>的桌面，帅到爆。再看看Ubuntu，开机基佬紫就不说了，桌面侧边栏真是丑到没话说。<br>首先要安装<code>User Themes</code>，</p><blockquote><p><a href="https://extensions.gnome.org/extension/19/user-themes/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/19/user-themes/</a></p></blockquote><p>为了更方便的安装插件、需要在Chrome中先安装<code>extensions.gnome.org</code>的插件。</p><p>安装好User Themes后(最好再装一个<code>dash to dock</code>或者<code>dash to panel</code>)就可以到gnome-look里挑一个中意的主题了。</p><blockquote><p><a href="https://www.gnome-look.org" target="_blank" rel="noopener">https://www.gnome-look.org</a></p></blockquote><p>主题的作者一般会在下载的地方写好安装方法。</p><h1 id="美化登录"><a href="#美化登录" class="headerlink" title="美化登录"></a>美化登录</h1><p>如果说桌面还可以接受的话、那登录界面真是人神共愤了。不过好在gnome-look里一样提供了很多gdm的主题。我个人比较推荐这个</p><blockquote><p><a href="https://www.gnome-look.org/p/1241489/" target="_blank" rel="noopener">https://www.gnome-look.org/p/1241489/</a></p></blockquote><p>作者的README写的也非常清楚</p><blockquote><p>复制bg-boat.jpg到背景目录<br>cp ~/Downloads/Ocean-blue-GDM3/bg-boat.jpg /usr/share/backgrounds/</p><p>备份默认的ubuntu.css<br>cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.bk</p><p>覆盖ubuntu.css<br>cp ~/Downloads/Ocean-blue-GDM3/ubuntu.css /usr/share/gnome-shell/theme/</p><p>重启<br>reboot -f</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本篇针对Ubuntu18.04或Ubuntu Gnome&lt;/strong&gt;&lt;br&gt;推荐一本书《鸟哥的Linux私房菜》，虽然
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://wooyme.github.io/tags/Ubuntu/"/>
    
      <category term="杂谈" scheme="http://wooyme.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x后端漫游指南(4)</title>
    <link href="http://wooyme.github.io/2019/01/17/Vert-x%E5%90%8E%E7%AB%AF%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97-4/"/>
    <id>http://wooyme.github.io/2019/01/17/Vert-x后端漫游指南-4/</id>
    <published>2019-01-17T10:09:03.000Z</published>
    <updated>2019-10-28T11:09:43.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非常非常久没有更新 <em>Vert.x后端漫游指南</em> 了。主要是因为之前觉得Vert.x的Web后端实在是没有什么好写的，都是一些常规操作。再者，也有很长一段时间没有碰Vert.x的后端开发了。但是呢，因为打算做一个Vert.x全栈的服务端应用，所以又把Web后端的部分拿出来了。</p><h1 id="API？"><a href="#API？" class="headerlink" title="API？"></a>API？</h1><p>虽然Vertx-Web也支持模板引擎这类的东西，但是无论是从潮流还是从Vertx支持程度的角度来看，前后端分离的开发方式更加适合现在的Web开发。那么既然前后端分离，提供一套完整、合理的API就非常重要了。<br>回顾一下之前的 <em>Vert.x后端漫游指南</em> ,我们使用了<code>Router.route(&quot;/api/path&quot;)</code>的方式来设置API。这种方式非常的简单粗暴，没有注解，没有配置文件，完完全全的硬编码。对于单人开发的简单服务来说，这样当然是没有问题的。但是当有了开发团队，需要前后端沟通的时候，这种硬编码的方式就变得很麻烦了。<br>一方面这意味着还得再单独写一份API文档给前端，</p><blockquote><p>程序员最讨厌两种事情，一是没有文档，二是写文档。</p></blockquote><p>另一方面是一旦要做什么修改，就必须要重新编译程序。  </p><h1 id="Swagger-amp-OpenAPI"><a href="#Swagger-amp-OpenAPI" class="headerlink" title="Swagger &amp; OpenAPI"></a>Swagger &amp; OpenAPI</h1><blockquote><p>Swagger <a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p></blockquote><blockquote><p>OpenApi <a href="https://www.openapis.org/" target="_blank" rel="noopener">https://www.openapis.org/</a></p></blockquote><p>OpenAPI和Swagger给API开发带来了不一样的体验。Swagger是一套非常完善的API开发工具，最新的版本已经提供了对OpenAPI 3.0 的支持。</p><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>Swagger使用yaml作为配置文件，</p><pre><code class="yaml">openapi: 3.0.0info:    title: Sample API    description: Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML.    version: 0.1.9servers:  - url: /v1    description: Optional server description, e.g. Main (production) server  - url: http://staging-api.example.com    description: Optional server description, e.g. Internal staging server for testing    paths:    /api/transactions/{id}:        get:            operationId: getTransactionsList            parameters:                -   name: id                    in: path                    required: true                    schema:                        type: string                     -   name: from                    in: query                    required: false                    schema:                        type: string                -   name: to                    in: query                    required: false                    schema:                        type: string            responses:                 200:                    content:                        application/json:                            schema:                                type: object        put:            operationId: putTransaction            parameters:                -   name: id                    in: path                    required: true                    schema:                        type: string            requestBody:                required: true                content:                    application/json:                        schema:                            type: object                            properties:                                from:                                    type: string                                    format: email                                to:                                    type: string                                    format: email                                value:                                    type: number                                    format: double                            additionalProperties: false                            required:                                - from                                - to                                - value            responses: ...</code></pre><p>大致上就是这个样子,详细的关于swagger中yaml配置的编写可以看官方文档</p><blockquote><p><a href="https://swagger.io/docs/specification/basic-structure/" target="_blank" rel="noopener">https://swagger.io/docs/specification/basic-structure/</a></p></blockquote><p>总体来说就是把原来的硬编码改成了文件配置的模式。通过<code>paths</code>和<code>get</code>,<code>put</code>,<code>post</code>,<code>delete</code>一起组成各种API，同时也通过<code>parameters</code>和<code>requestBody</code>规定了各个API所需的参数，以及最后的<code>responses</code>用于规定服务端返回的数据结构。  </p><h2 id="Swagger-Codegen"><a href="#Swagger-Codegen" class="headerlink" title="Swagger-Codegen"></a>Swagger-Codegen</h2><p>有了配置文件之后当然还是要能够生成对应的代码才行。Swagger提供了Swagger-Codegen来生成各种语言、框架的服务端和客户端代码。</p><blockquote><p><a href="https://github.com/swagger-api/swagger-codegen" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-codegen</a></p></blockquote><p>如果要使用<strong>OpenAPI 3.0</strong>的话就必须要安装3.0.0版本以上的Swagger-Codegen。目前由于这个工具还在频繁的更新中，所以bug也是挺多的，特别是在客户端代码的部分，前几天就遇到生成的<code>typescript-angular</code>的代码里没有把body放到<code>post</code>和<code>put</code>的参数里的问题。<br>如果开发的时候遇到了不可理喻的问题，就去issues里看看吧。</p><h1 id="Vert-x的Web-API-Contract"><a href="#Vert-x的Web-API-Contract" class="headerlink" title="Vert.x的Web API Contract"></a>Vert.x的Web API Contract</h1><p>在写完Swagger之后呢，就要来看看Vert.x的Web API Contract了。为什么明明有Swagger了，Vert.x的团队还要搞个Contract呢，因为<strong>Swagger不支持Vert.x</strong>( 笑 。Swagger虽然已经支持很多主流框架了，但是很明显Vert.x还不是那么的”主流”。</p><blockquote><p>官方文档 <a href="https://vertx.io/docs/vertx-web-api-contract/java/" target="_blank" rel="noopener">https://vertx.io/docs/vertx-web-api-contract/java/</a></p></blockquote><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>Maven</p><pre><code class="xml">&lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-web-api-contract&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Gradle</p><pre><code class="Groovy">dependencies { compile &#39;io.vertx:vertx-web-api-contract:3.6.2&#39;}</code></pre><h2 id="创建一个工厂"><a href="#创建一个工厂" class="headerlink" title="创建一个工厂"></a>创建一个工厂</h2><pre><code class="Java">OpenAPI3RouterFactory.create(vertx, &quot;yaml的路径,支持本地文件或是http、https的地址&quot;, ar -&gt; {  if (ar.succeeded()) {    //得到了一个路由工厂    OpenAPI3RouterFactory routerFactory = ar.result();  } else {    Throwable exception = ar.cause();  }});</code></pre><p>得到这样一个工厂之后，就可以添加各种处理器</p><pre><code class="Java">routerFactory.addHandlerByOperationId(&quot;awesomeOperation&quot;, routingContext -&gt; {  RequestParameters params = routingContext.get(&quot;parsedParameters&quot;);  RequestParameter body = params.body();  JsonObject jsonBody = body.getJsonObject();  // Do something with body});routerFactory.addFailureHandlerByOperationId(&quot;awesomeOperation&quot;, routingContext -&gt; {  // Handle failure});</code></pre><p>这里的<code>OperationId</code>就对应了yaml文件中的<code>OperationId</code>，对于需要做权限控制的路由，还可以添加<code>Security Handler</code></p><pre><code class="Java">routerFactory.addSecurityHandler(&quot;security_scheme_name&quot;, securityHandler);</code></pre><p>对于之前我们用到的SessionHandler、CookieHandler，可以通过调用<code>addGlobalHandler</code>的方式来添加。需要注意的是BodyHandler不能用<code>addGlobalHandler</code>，<code>OpenAPI3RouterFactory</code>为它提供了专门的方法。</p><p>在添加完处理器之后，就可以生产路由了</p><pre><code class="Java">Router router = routerFactory.getRouter();HttpServer server = vertx.createHttpServer(new HttpServerOptions().setPort(8080).setHost(&quot;localhost&quot;));server.requestHandler(router).listen();</code></pre><p>这部分跟之前相差无几，唯一要注意的是<code>router::accept</code>已经被弃用了，现在直接向<code>requestHandler</code>传递<code>router</code>就可以了。</p><h1 id="Vert-x的Web-API-Service"><a href="#Vert-x的Web-API-Service" class="headerlink" title="Vert.x的Web API Service"></a>Vert.x的Web API Service</h1><blockquote><p>Contract之后再来个Service是要干什么。</p></blockquote><p>各位肯定也都发现了，Web API Contract用起来是一点都不方便，先不说每个处理器都要通过<code>operationId</code>单独绑定，就说处理器得到的参数吧，一点都不智能，完全没有用到Yaml中配置的<code>parameters</code>，参数还是要像以前一样从<code>RoutingContext</code>里获取。<br>为了获得更好的开发体验，就必须要引入Web API Service了。</p><blockquote><p>官方文档 <a href="https://vertx.io/docs/vertx-web-api-service/java/" target="_blank" rel="noopener">https://vertx.io/docs/vertx-web-api-service/java/</a></p></blockquote><h2 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h2><p>Maven</p><pre><code class="xml">&lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-codegen&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;classifier&gt;processor&lt;/classifier&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-web-api-service&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Gradle</p><pre><code class="Groovy">dependencies { compile &#39;io.vertx:vertx-codegen:3.6.2:processor&#39; compile &#39;io.vertx:vertx-web-api-service:3.6.2&#39;}</code></pre><p>可以看到，除了<code>vertx-web-api-service</code>以外，还引入了<code>vertx-codegen</code>。在codegen面前，没有什么问题是解决不了的。</p><h2 id="使用Interface"><a href="#使用Interface" class="headerlink" title="使用Interface"></a>使用Interface</h2><pre><code class="Java">@WebApiServiceGeninterface TransactionService { void getTransactionsList(String from, String to, OperationRequest context, Handler&lt;AsyncResult&lt;OperationResponse&gt;&gt; resultHandler); void putTransaction(JsonObject body, OperationRequest context, Handler&lt;AsyncResult&lt;OperationResponse&gt;&gt; resultHandler);}</code></pre><p>Web API Service提供了另一种绑定handler的方式。接口中的方法名称需要和<code>operationId</code>相同，其中的参数也需要和<code>parameters</code>相同，需要注意的是如果使用<code>requestBody</code>，则对应<code>JsonObject body</code>。最后的<code>OperationRequest context</code>和<code>Handler&lt;AsyncResult&lt;OperationResponse&gt;&gt; resultHandler</code>是必须写的部分。分别代表了请求的额外信息和响应的对象。</p><ul><li>OperationRequest<ul><li>getHeaders 请求头信息</li><li>getParams 请求参数</li><li>getUser 如果使用Auth，User就在这里</li><li>getExtra 可以通过向RouterFactory添加<code>setExtraOperationContextPayloadMapper</code>来<strong>额外设置extra</strong>，这个很重要,通过这种方式可以把session带到handler里来。</li></ul></li><li>OperationResponses<ul><li>响应头</li><li>响应状态</li><li>响应主体</li></ul></li></ul><h2 id="添加Service到RouterFactory"><a href="#添加Service到RouterFactory" class="headerlink" title="添加Service到RouterFactory"></a>添加Service到RouterFactory</h2><pre><code class="Kotlin">OpenAPI3RouterFactory.create(vertx,&quot;yaml文件路径&quot;){    val serviceImpl = ServiceImpl()    ServiceBinder(vertx)        .setAddress(&quot;my-service&quot;)        .register(Service::class.java,ServiceImpl)    it.result().mountServiceInterface(Service::class.java,&quot;my-service&quot;)    //因为Web API Contract并不会处理yaml中的servers，所以需要自己设置sub-router    val router = Router.router(vertx).mountSubRouter(&quot;/api&quot;,it.result().router)    vertx.createHttpServer().requestHandler(router).listen(80){        logger.info(&quot;Listen at 80&quot;)    }    }</code></pre><p>这样就可以非常方便的使用Vert.x的Web API Service了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在使用了OpenAPI之后，Vert.x的后端开发就算是比较完整了。这种开发方式也能给前端开发提供很多便利，比硬编码的模式要更加适合现在的开发形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;非常非常久没有更新 &lt;em&gt;Vert.x后端漫游指南&lt;/em&gt; 了。主要是因为之前觉得Vert.x的Web后端实在是没有什么好写的，都是一些
      
    
    </summary>
    
    
      <category term="Vert.x" scheme="http://wooyme.github.io/tags/Vert-x/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native求生指南(3)</title>
    <link href="http://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-3/"/>
    <id>http://wooyme.github.io/2018/12/22/Kotlin-Native求生指南-3/</id>
    <published>2018-12-22T09:09:55.000Z</published>
    <updated>2019-01-03T09:24:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上一篇地址"><a href="#上一篇地址" class="headerlink" title="上一篇地址"></a>上一篇地址</h1><blockquote><p><a href="https://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-2/">https://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-2/</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇意外的花了整篇的篇幅写<em>cinterop</em>,INTEROP的文档比我想的要长太多。那么这一篇就来写一下Kotlin Native的多线程模型。由于Kotlin Native还在频繁更新中，所以多线程API和注解还是有可能出现较大变化的，本篇文章针对的是<strong>Kotlin Native v0.9</strong>,其他版本如有差异，请忽略这篇文章，以官方为准。</p><blockquote><p><a href="https://github.com/JetBrains/kotlin-native/blob/master/CONCURRENCY.md" target="_blank" rel="noopener">https://github.com/JetBrains/kotlin-native/blob/master/CONCURRENCY.md</a></p></blockquote><p>并且这篇文章只讲Kotlin Native的多线程模型，并不涉及协程，想要了解协程的朋友，还是看官方的文档吧。</p><h1 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h1><p>可能说到多线程，我们马上就会想到<code>pthread</code>之类的东西。没错<code>pthread</code>作为<strong>POSIX</strong>提供的跨平台多线程API可以说是非常深入人心了。你问我Kotlin Native支不支持<code>pthread</code>,那肯定是支持的，我们完全可以像在C/C++中做的那样，通过<code>pthread</code>创建新的线程，只是要在线程启动的时候运行一下<code>kotlin.native.initRuntimeIfNeeded()</code>。<br>但是，实际上Kotlin Native给我们提供了一个更好的选择——<strong>Worker</strong>。让我们来看看官方对Worker的介绍</p><blockquote><p>不同于线程的是，Kotlin Native引入了Worker这个概念:能够并行处理请求队列的控制流(concurrently executed control flow streams with an associated request queue)。Workers与Actor模型中的Actor很像，一个Worker可以与其他Worker交换数据。<strong>在任何时候可变的对象只会被一个Worker拥有</strong>。</p></blockquote><p>好像不是很好理解，我们看官方给的例子</p><pre><code class="Kotlin">package sample.workersimport kotlin.native.concurrent.*data class WorkerArgument(val intParam: Int, val stringParam: String)data class WorkerResult(val intResult: Int, val stringResult: String)fun main() {    val COUNT = 5    //创建5个Worker对象    val workers = Array(COUNT, { _ -&gt; Worker.start() })    for (attempt in 1..3) {        val futures = Array(workers.size) { workerIndex -&gt;            workers[workerIndex].execute(TransferMode.SAFE, {                //传入要给Worker处理的参数                WorkerArgument(workerIndex, &quot;attempt $attempt&quot;)            }) { input -&gt;                //Worker处理参数                var sum = 0                for (i in 0..input.intParam * 1000) {                    sum += i                }                WorkerResult(sum, input.stringParam + &quot; result&quot;)            }        }        val futureSet = futures.toSet()        var consumed = 0        while (consumed &lt; futureSet.size) {            //等待运行结束的Workers            val ready = waitForMultipleFutures(futureSet, 10000)            ready.forEach {                //处理Worker的运行结果                it.consume { result -&gt;                    if (result.stringResult != &quot;attempt $attempt result&quot;) throw Error(&quot;Unexpected $result&quot;)                    consumed++                }            }        }    }    workers.forEach {        //终止Worker        it.requestTermination().result    }    println(&quot;Workers: OK&quot;)}</code></pre><p>这就是一个通过创建多个Workers来并行处理数据的例子。可以看到跟Actor模型还挺像的。在<code>Worker.execute</code>的第一个参数里传入生成待处理数据的lambda，然后在第二个参数里传入处理数据的lambda。然后在需要的时候调用<code>future.consume</code>,传入处理结果的lambda。这一切看上去跟Java上的许多异步框架别无二致，但实际上。。。。后面会讲到其中的坑爹之处。  </p><h1 id="全局变量和单例"><a href="#全局变量和单例" class="headerlink" title="全局变量和单例"></a>全局变量和单例</h1><blockquote><p>虽然Worker和线程的实现方式并不相同，但是行为类似，所以后面就不严格区分Worker和线程了</p></blockquote><p>在线程间共享数据最简单的方法就是全局变量了，但同时全局变量也是导致多线程出现各种问题的罪魁祸首。于是Kotlin Native引入了一系列的限制措施来保证全局变量不会影响Worker模型的工作。</p><ul><li>除非添加了特殊的注解，不然全局变量只能在主线程中被访问，如果其他线程试图访问这个变量会报<code>IncorrectDereferenceException</code>异常</li><li>一个添加了<code>@ThreadLocal</code>的全局变量会在每个线程里复制一份，所以每个线程都是独享这个变量的，<strong>某个线程对变量的改动对其他线程不可见</strong></li><li>一个添加了@SharedImmutable的变量是能在线程间共享的，但是<strong>它会被冻结</strong>，后续如果程序尝试修改这个变量也是会抛出异常的。需要注意的是，这个冻结不受<code>var</code>或是<code>val</code>的影响，就算声明的时候是<code>var</code>的只要冻结了就不能再被修改了。同时需要注意的是，<strong>一个被冻结的变量是不能被解冻的</strong></li><li>对于单例(objects)，<strong>除非添加@ThreadLocal注解,不然会被冻结从而可以在线程间共享</strong>。对于其中的属性，lazy是被允许的。</li></ul><p>相信对于从JVM转过来的人来说，我们还是习惯写单例而不是全局变量。就算是保存一个全局变量，也还是习惯于放在一个单例里作为单例的属性。于是坑就出现了。</p><pre><code class="Kotlin">object Foo{    lateinit var A:String    init{        //某些操作....        A = ......    }    fun foo(){        //某些操作.....        A = .....    }}</code></pre><p>根据上面的规则，猜猜看结果会是什么样吧。我想大部分人都会认为<code>init</code>中对A的赋值应该是可以的，至于<code>foo</code>中的赋值则要看是在哪个线程里执行了。但事实是，两个都不行，无论什么情况都不行。即使A是<code>lateinit</code>的，只要Foo被<code>frozen</code>了，里面的属性就不能再被修改。Kotlin Native是真的很严格，就算我们自始至终只有一个主线程也不行。所以<code>object</code>几乎是必须加上<code>@ThreadLocal</code>注解。<br>但是加上<code>@ThreadLocal</code>真的就能解决问题了吗，规则里说，加上<code>@ThreadLocal</code>的变量会在每个线程间复制一份，不知道你们是怎么理解的，反正我最开始看到这端话的时候觉得这个<em>复制</em>应该会在<em>新的线程创建的时候把创建这个线程的线程中的变量复制到新的线程上</em>。举个例子</p><pre><code class="Kotlin">@ThreadLocalobject Foo{    var A:String? = null}fun main(){    Foo.A = &quot;Hello&quot;    Worker.start().execute(Transport.SAFE,{}){        println(Foo.A)    }.consume{}}//我期望的输出Hello//实际上的输出null</code></pre><blockquote><p>这谁顶得住啊</p></blockquote><p>总之就是被Kotlin Native的文档秀了一脸。它说的复制，就是保证其他线程上也有一个叫做<code>Foo</code>的单例。而单例里面是什么则完全取决于它初始化完了是什么。这简直是颠覆了我对多线程的认识。那么正确的做法是什么呢。</p><pre><code class="Kotlin">@ThreadLocalobject Foo{    var A:String? = null}fun main(){    Foo.A = &quot;Hello&quot;    Worker.start().execute(Transport.SAFE,{        Foo.A    }){ str-&gt;        Foo.A = str        println(Foo.A)    }.consume{}}</code></pre><p><code>execute</code>的第一个lambada参数就给我们用来干这个事情的，这是唯一一个能让其他线程与主线程产生联系的地方。我们需要在这里把想要<em>复制</em>的值传到子线程，然后在子线程里做<em>粘贴</em>的工作。  </p><h1 id="共享可变量"><a href="#共享可变量" class="headerlink" title="共享可变量"></a>共享可变量</h1><p>但是这样的<em>复制</em>很明显是不够的，比如说我想在Worker里运行一个Event Loop，我必然要在Worker运行的时候向它传递一些数据。于是这个时候就必须要跳出Kotlin Native的管理，寻求C的帮助了。<br>虽然Kotlin的变量在线程间是独立的，但是通过<code>nativeHeap.alloc</code>分配的内存在线程间依然是共享的。所以我们就可以写出这样的代码</p><pre><code class="Kotlin">fun main(){    val ptr = nativeHeap.allocArray&lt;ByteVar&gt;(10)    memScope{        memcpy(ptr,&quot;A&quot;.cstr.ptr,&quot;A&quot;.cstr.size)    }    val future = Worker.start().execute(Transport.SAFE,{        ptr    }){ _ptr-&gt;        while(true){            println(_ptr.toKString())            sleep(100)        }    }    sleep(100)    memScope{        memcpy(ptr,&quot;B&quot;.cstr,ptr,&quot;B&quot;.cstr.size)    }    future.consume{}}</code></pre><p>通过这种方法就可以在线程间共享可变的变量了。当然这和传统的多线程模型一样，如果设计不当依然会导致各种多线程中常见的问题。<br>这样的共享方式是比较原始的，毕竟我们共享的是最原始的数据，如果想要共享一个对象的话，就需要使用<code>Object subgraph detachment</code></p><blockquote><p>一个没有外部引用的对象子图可以通过<code>DetachedObjectGraph&lt;T&gt;</code>解除连接(disconnected)变成一个<code>COpaquePointer</code>从而存储在C的结构体中，接着可以在任意的线程或Worker中通过<code>DetachedObjectGraph&lt;T&gt;.attach()</code>重新连接得到这个对象子图。</p></blockquote><p>配合前面的方法，就可以在线程间共享对象了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kotlin Native的多线程模型就如Kotlin的空安全机制一样，可以说是为了解决传统多线程中的问题做出了许多设计上的规范，但是为了应对一些特殊的情况，这种规范也是要做出让步的，这种时候还是得我们自己来注意多线程间的问题。<br>那么至此，Kotlin Native的系列就算是结束了。基本上把我在做KN开发时候遇到的一些坑都写在里面了，要说体验如何的话，一是资料太少了，官方的又只有英文，有些是它没说清楚，有些是我理解有差，导致了许多莫名其妙的问题。二是库太少了，整个github上，关于Kotlin Native的库只有两个，一个是只有IOS版本的Ktor，另一个是libui的Kotlin Native Binding，而且好久没有更新了。三是太依赖C语言了，没点C/C++开发基础还真搞不定。<br>总之Kotlin Native作为一个连1.0版本都没到的语言(姑且叫它语言吧)，能用它写出一个还算像样的工具已经是挺不错的。相信只要JetBrains没有放弃KN，KN应该也会成为一门像Go一样大众的语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;上一篇地址&quot;&gt;&lt;a href=&quot;#上一篇地址&quot; class=&quot;headerlink&quot; title=&quot;上一篇地址&quot;&gt;&lt;/a&gt;上一篇地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://wooyme.github.io/2018/12/22/
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://wooyme.github.io/tags/Kotlin/"/>
    
      <category term="Native" scheme="http://wooyme.github.io/tags/Native/"/>
    
      <category term="C" scheme="http://wooyme.github.io/tags/C/"/>
    
      <category term="多线程" scheme="http://wooyme.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native求生指南(2)</title>
    <link href="http://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-2/"/>
    <id>http://wooyme.github.io/2018/12/22/Kotlin-Native求生指南-2/</id>
    <published>2018-12-22T06:36:17.000Z</published>
    <updated>2018-12-22T09:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上一篇地址"><a href="#上一篇地址" class="headerlink" title="上一篇地址"></a>上一篇地址</h1><blockquote><p><a href="https://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-1/">https://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-1/</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<strong>Kotlin Native求生指南1</strong>中我们已经提到了KN的内存模型和GC。那么在本篇中，我们将一起了解一下KN的<em>Cinterop</em>。</p><h1 id="Cinterop"><a href="#Cinterop" class="headerlink" title="Cinterop"></a>Cinterop</h1><p>由于Kotlin Native内置的库实在是太少了，我们不得不大量依赖C的库，于是<em>Cinterop</em>就诞生了。<em>Cinterop</em>的作用就是把C的库翻译成可供Kotlin使用的<em>klib</em>。需要注意的是，现在Cinterop只支持C语言的库。不过实际上只要提供的头文件是C语言的即可，具体实现还是可以使用C++。</p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>要使用Cinterop需要修改一下Gradle。</p><pre><code class="Groovy">kotlin {    targets {        fromPreset(presets.linuxX64, &#39;linux&#39;)        configure([linux]) {            compilations.main.outputKinds(&#39;EXECUTABLE&#39;)            compilations.main.entryPoint = &#39;main&#39;            //我添加的代码            compilations.main{                cinterops {                    //包名称，需要与.def文件名对应,也可以增加一个参数修改def文件位置，一般不需要                    libui {                        packageName &#39;libui&#39;                    }                }            }        }    }}</code></pre><p>修改好gradle之后，应该就可以看到<code>interop/cinteropLibuiLinux</code>命令</p><h2 id="def"><a href="#def" class="headerlink" title="def"></a>def</h2><p>.def文件需要放在<code>src/nativeInterop/cinterop</code>里，并且要与gradle中的包名相同。比如这里就应该是<code>libui.def</code>。现在让我们来看看.def文件中应该是什么样的</p><pre><code class="bash">#如果涉及到多个文件，都用空格隔开#设置头文件位置headers=/usr/include/ui.h#包名package=libui#静态库文件名staticLibraries = libui.a#静态库路径libraryPaths = /home/wooyme/Projects/libui/build/out</code></pre><p>这样的.def文件是针对静态库使用的，如果要用动态链接库则需要改成下面这样</p><pre><code class="bash">#如果涉及到多个文件，都用空格隔开#设置头文件位置headers=/usr/include/ui.h#包名package=libui//编译选项，供编译器clang使用compilerOpts.linux= -I/usr/include///链接选项，供链接器ldd使用linkerOpts.linux = -L/usr/lib/x86_64-linux-gnu -lui</code></pre><p>动态链接库的使用要比静态库更加复杂一点，其实就是开发C/C++经常会用到的这些参数，在linux上，我们可以使用<strong>pkg-config</strong>来获得这些参数,以libui为例</p><pre><code class="bash">pkg-config --cflags --libs libui</code></pre><p>然后<strong>pkg-config</strong>就会打印相应参数，非常的方便。<br>一切都配置完之后，就只需要运行一下<code>interop/cinteropLibuiLinux</code>就可以了。</p><h2 id="使用Interop"><a href="#使用Interop" class="headerlink" title="使用Interop"></a>使用Interop</h2><p>完成了上面的操作之后，就可以看到IDEA的<code>External libraries</code>里多了<code>xxx-cinterop-libui.klib</code>，里面就是从C语言转换过来的Kotlin Native Library。你可能会去试图打开里面的内容，看看都转换出了什么东西，但事实是你只能看到一堆被注释标记着的，莫名其妙的代码。<br><strong>不要试图去看Cinterop转换后的knm文件</strong>，如果想了解库中提供了哪些函数的话，正确的做法是去看原始的C语言头文件。  </p><p>下面我翻一下 Kotlin Native 在 github 上的 INTEROP.md </p><blockquote><p>原文<br><a href="https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md" target="_blank" rel="noopener">https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md</a></p></blockquote><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>所有支持的C类型都会被转换成Kolin 类型</p><ul><li>有符号、无符号整形和浮点型都会被转换到Kotlin上，并且保持相同的长度</li><li>指针和数组会被转换成CPointer<t>?</t></li><li>枚举类型可以根据def文件配置转换成Kotlin的枚举类或是整形</li><li>结构体会被转换成对应的类</li><li>typedef会被转换成typealias</li></ul><p>这里还有一段很难翻译，它引入了一个左值(<code>lvalue</code>),大意是Cinterop会给这些转换过来的类型加一个<code>${type}Var</code>,然后可以通过<code>${type}Var.value</code>调用这个类型本身的值，就像C++的Reference</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>CPointer<t>的T必须是上述左值之一，比如说<code>struct S*</code>对应<code>CPointer&lt;S&gt;</code>,<code>int8_t*</code>对应<code>CPointer&lt;int8_tVar&gt;</code>,<code>char**</code>对应<code>CPointer&lt;CPointerVar&lt;ByteVar&gt;</code><br>C语言的空指针，对应Kotlin的null, <code>CPointer&lt;T&gt;</code>可以使用所有kotlin的空安全操作<code>？:</code>,<code>?.</code>,<code>!!</code>等。比如</t></p><pre><code class="Kotlin">val path = getenv(&quot;PATH&quot;)?.toKString() ?: &quot;&quot;</code></pre><p>由于数组也被转换成<code>CPointer&lt;T&gt;</code>,所以<code>CPointer&lt;T&gt;</code>也支持<code>[]</code>操作,比如</p><pre><code class="Kotlin">fun shift(ptr: CPointer&lt;BytePtr&gt;, length: Int) {    for (index in 0 .. length - 2) {        ptr[index] = ptr[index + 1]    }}</code></pre><p><code>CPointer&lt;T&gt;</code>的<code>.pointed</code>属性返回T,比如说<code>CPointer&lt;ByteVar&gt;</code>就返回<code>ByteVar</code>，而<code>ByteVar</code>就是就是<code>Byte</code>的左值，然后可以通过<code>ByteVar.value</code>得到这个<code>Byte</code>。左值又可以通过<code>.ptr</code>得到对应的<code>CPointer&lt;T&gt;</code><br><code>void*</code>对应<code>COpaquePointer</code>,这是所有其他指针类型的父类，所以如果一个C函数的参数是<code>void*</code>，Kotlin中可以给他传任何<code>CPointer</code><br>指针类型转换可以使用<code>.reinterop&lt;T&gt;</code>,比如</p><pre><code class="Kotlin">val intPtr = bytePtr.reinterpret&lt;IntVar&gt;()//或val intPtr: CPointer&lt;IntVar&gt; = bytePtr.reinterpret()</code></pre><p>这个跟C语言里的强制转换是一样不安全的。<br>同样的，<code>CPointer&lt;T&gt;</code>也可以通过<code>.toLong()</code>和<code>.toCPointer&lt;T&gt;</code>与<code>Long</code>互相转换,当然这也是不安全的。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存可以通过使用<code>NativePlacement</code>接口分配,如</p><pre><code class="Kotlin">val byteVar = placement.alloc&lt;ByteVar&gt;()//或val bytePtr = placement.allocArray&lt;ByteVar&gt;(5)</code></pre><p>最常用的是<code>nativeHeap</code>,它就和<code>malloc</code>与<code>free</code>一样</p><pre><code class="Kotlin">val buffer = nativeHeap.allocArray&lt;ByteVar&gt;(size)//use buffer.....nativeHeap.free(buffer)</code></pre><p>除此之外还可以使用<code>memScope</code>，我们在前一篇已经写过，这里就不再赘述。</p><h3 id="传递指针"><a href="#传递指针" class="headerlink" title="传递指针"></a>传递指针</h3><p>虽然C语言的指针对应的是<code>CPointer&lt;T&gt;</code>，但是C语言的函数中的指针参数对应的是<code>CValuesRef&lt;T&gt;</code>。当我们传入的参数是<code>CPointer&lt;T&gt;</code>时，一切都很正常，但是除了<code>CPointer&lt;T&gt;</code>，我们还可以传别的东西。设计<code>CValuesRef&lt;T&gt;</code>就是为了能够让我们在向函数传递数组的时候不需要显式分配一块内存，Kotlin为我们提供了这些方法。</p><ul><li>${type}Array.toCValues(), type是Kotlin的基本类型</li><li>Array&lt;CPointer&lt; T &gt;?&gt;.toCValues(), List&lt;CPointer&lt; T &gt;?&gt;.toCValues()</li><li>cValuesOf(vararg elements: ${type}), type是基本类型或者指针</li></ul><p>比如可以这么写</p><pre><code class="C">//C语言void foo(int* elements, int count);...int elements[] = {1, 2, 3};foo(elements, 3);</code></pre><pre><code class="Kotlin">//Kotlinfoo(cValuesOf(1, 2, 3), 3)</code></pre><h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><p>不同于其他的指针，<code>const char*</code>被转换成Kotlin的String。除此之外，还有其他的一些工具可以让Kotlin的String与C语言的<code>const char*</code>进行转换</p><ul><li>fun CPointer&lt; ByteVar &gt;.toKString(): String</li><li>val String.cstr: CValuesRef&lt; ByteVar &gt;<br>要得到<code>.cstr</code>的指针，需要给<code>cstr</code>分配内存,比如<pre><code class="Kotlin">//官方这里是这么写的，但是不知道为什么我这里不行，我只能在memScope里调用.cstr.ptrval cString = kotlinString.cstr.getPointer(nativeHeap)//我的版本memScope{    val cString = kotlinString.cstr.ptr}</code></pre>在所有情况下，C语言的string都可以使用UTF-8编码<br>如果不想要使用<code>const char*</code>到<code>String</code>的自动转换，可以在def文件里设置<pre><code>noStringConversion = LoadCursorA LoadCursorW</code></pre>调用LoadCursorA，LoadCursorW就变成了这样<pre><code class="Kotlin">memScoped {  LoadCursorA(null, &quot;cursor.bmp&quot;.cstr.ptr)   // for ASCII version  LoadCursorW(null, &quot;cursor.bmp&quot;.wcstr.ptr)  // for Unicode version}</code></pre><h3 id="传递、接收结构体"><a href="#传递、接收结构体" class="headerlink" title="传递、接收结构体"></a>传递、接收结构体</h3><em>这个其实不是很重要，因为大部分成熟一点的C的库都不会直接把结构体本身作为参数或是返回值,所以我就直接跳过了，关于这一段的原文也不长</em></li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>要把Kotlin的函数变成C语言的函数指针需要使用<code>staticCFunction(::kotlinFunction)</code>,<code>staticCFunction</code>也接受<strong>lambda</strong>作为参数，顺便一提，<code>staticCFunction</code>依然继承了Kotlin的暴力美学，就像最初的40+参数的lambda一样。这里要注意的是，这个lambda必须是<em>静态</em>的，也就是不能用闭包，不能用<em>class</em>内的值，而且现在<code>staticCFunction</code>有个bug，不能直接使用<code>object</code>内的方法</p><pre><code class="Kotlin">object A{    fun foo(){}}//这样不行staticCFunction(A::foo)//这样OKstaticCFunction{    A.foo()}</code></pre><p>如果callback没有运行在主线程里，那么就需要在callback开头加上<code>kotlin.native.initRuntimeIfNeeded()</code>,初始化Kotlin Native环境，这一点和Kotlin Native的多线程模型有关系。</p><h4 id="向callback传递数据"><a href="#向callback传递数据" class="headerlink" title="向callback传递数据"></a>向callback传递数据</h4><p>由于callback不能使用闭包这类的操作，传递参数就很重要了。大多数的C API都允许用户向callback传递一些指针，但是Kotlin的类并不能直接传递给C，所以就需要一些操作把类转换成指针。</p><pre><code class="Kotlin">val stableRef = StableRef.create(kotlinReference)val voidPtr = stableRef.asCPointer()</code></pre><p>把指针转换成Kotlin类</p><pre><code class="Kotlin">val stableRef = voidPtr.asStableRef&lt;KotlinClass&gt;()val kotlinReference = stableRef.get()</code></pre><p>这样两者的转换就完成了，要注意的是,创建的<code>stableRef</code>需要用<code>.dispose()</code>手动释放，以防止内存泄露。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>大意就是提供了一个<code>.convert&lt;T&gt;()</code>方法，能把基本类型转换成C函数需要的类型，跟<code>.toShort()</code>,<code>toUInt()</code>等方法有相同的作用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我实在是没想到一个<em>Cinterop</em>可以写这么长，本来还想在这一篇里把KN的<em>多线程模型</em>给写了，这么看来还是再写第三篇好了。这里稍微说一下我的<em>Cinterop</em>使用体验，总的来说就是功能实现的很完善了，但是用户体验真的很烂。其实最大的问题就是Kotlin是一门OOP的语言，但是C语言不是。其实很多C语言的库都有OOP的影子，无论是命名方式还是那些函数与Kotlin扩展函数别无二致的第一个参数，如果KN的<em>Cinterop</em>能够更加智能一点的话应该会有更好的体验。<br>这一点，我也在Kotlin Native的github上提了issue，官方表示会考虑通过在def中增加一些选项的方式来修改<em>Cinterop</em>的行为</p><blockquote><p><a href="https://github.com/JetBrains/kotlin-native/issues/2486" target="_blank" rel="noopener">https://github.com/JetBrains/kotlin-native/issues/2486</a></p></blockquote><p>Kotlin Native，路途还很漫长</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;上一篇地址&quot;&gt;&lt;a href=&quot;#上一篇地址&quot; class=&quot;headerlink&quot; title=&quot;上一篇地址&quot;&gt;&lt;/a&gt;上一篇地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://wooyme.github.io/2018/12/22/
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://wooyme.github.io/tags/Kotlin/"/>
    
      <category term="Native" scheme="http://wooyme.github.io/tags/Native/"/>
    
      <category term="C" scheme="http://wooyme.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native求生指南(1)</title>
    <link href="http://wooyme.github.io/2018/12/22/Kotlin-Native%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97-1/"/>
    <id>http://wooyme.github.io/2018/12/22/Kotlin-Native求生指南-1/</id>
    <published>2018-12-21T16:13:19.000Z</published>
    <updated>2018-12-21T18:15:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><blockquote><p><a href="https://github.com/Wooyme/Wsocks-Naitve-Client" target="_blank" rel="noopener">https://github.com/Wooyme/Wsocks-Naitve-Client</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>C++是一门好语言，Go也是一门好语言，Kotlin Native不是。</p></blockquote><p>首先确定一个观点，写Kotlin-JVM不一定要很懂Java，比如我自己。但是写Kotlin-Native要是不懂C，那就等着吃屎吧。Kotlin Native不是一个让我们跳过C语言走上Native开发道路的神器，至少现在不是。如果你想要Native又不想学C有关的东西的话，选Go吧，我能在这里列举1000个Go的优点和0个缺点。如果一定要说Go有什么缺点的话，那就只能是程序崩溃的时候Go打印的栈信息不能像Java那样漂亮。<br>当然Kotlin Native也不是一无是处，至少它可以督促我再复习一遍C语言的知识。 </p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>现在IDEA和CLION都可以支持Kotlin Native的开发。这个项目我用的是IDEA和Gradle，在开发这个项目之前我也用过CLION和Cmake的组合，要做个比较的话，还是Gradle更加适合我们这些从Kotlin-JVM转过来的玩家，毕竟对于不熟悉Cmake的人来说，看看别人写的CmakeList就已经够头疼的了，更何况要自己写。<br>顺便一提，我是在Ubuntu18.04上开发的。Windows和Linux上开发可能会有比较大的差异，还是推荐Windows上装一下Cygwin，能一定程度上减小这个差异。</p><h1 id="第一个工-小-程-坑"><a href="#第一个工-小-程-坑" class="headerlink" title="第一个工(小)程(坑)"></a>第一个工(小)程(坑)</h1><p>从IDEA里创建一个工程是很容易的。不过我遇到了一个小坑，IDEA创完工程之后会出现kt文件打不开的情况，应对的办法是<code>File-&gt;Invalidate Cache/Restart...</code><br>从这第一个坑开始，我们就踏上了Kotlin Native的漫漫坑爹路。工程创建之后会有一个默认的文件，里面是个hello world，我们编译运行一下。编译这个过程只能从Gradle里执行，在<code>other</code>里<code>runProgram</code>，顺利的话Hello World就就会成功打印出来。这里应该不会遇到什么问题，Gradle会智能的下载KN的编译器，只是可能会有点慢。</p><h2 id="我能干什么"><a href="#我能干什么" class="headerlink" title="我能干什么"></a>我能干什么</h2><p>爬过第一个坑之后，你可能迫不及待的想写点什么，比如来一个文件IO，你可能会习惯性的写一个<code>File</code>然后等待IDEA的语法提示，但是令人失望的是，IDEA除了把你的<code>File</code>标记为红色以外什么都不会做。然后你也许还会试一试其他你在JVM里经常用的类，但是它们多半没有，除了<code>StringBuilder</code>这个SB，它还是依然坚挺。<br>这个时候你可能才意识到，大清亡了，世界变了，原来的那些小伙伴都不在了。剩下的只有少的可怜的<em>Kotlin标准库</em>和陌生的<em>stdlib</em>、<em>posix</em>、<em>win32</em>或者<em>linux</em>、<em>darwin</em>以及我至今不能理解为什么要放在默认支持库里的<em>zlib</em>(我觉得唯一的可能就是JetBrains的人想试试cinterop好不好用)。</p><h2 id="认清现实"><a href="#认清现实" class="headerlink" title="认清现实"></a>认清现实</h2><p>好了，既然之前的都用不了了，那就不得不重新开始。让我们来看一看Kotlin Native的文件操作应该是什么样的。</p><pre><code class="Kotlin">//读取一个完整的文件，保存到String中fun main(){    val fp = fopen(myHome+&quot;save.json&quot;, &quot;r&quot;) ?: return println(&quot;Cannot open&quot;)    val fileStat = nativeHeap.alloc&lt;stat&gt;()    stat(myHome+&quot;save.json&quot;,fileStat.ptr)    val size = fileStat.st_size.toInt()+1    val bytes = nativeHeap.allocArray&lt;ByteVar&gt;(size)    fread(bytes,size.toULong(),size.toULong(),fp)    val text = bytes.toKString()    nativeHeap.free(fileStat.ptr)    fclose(fp)}</code></pre><p>OK,先说明一下，官方的例程里很少使用nativeHeap，它们比较喜欢用memScope{}，这两个的区别我会在之后说明。现在先让我们看完这段代码。相信如果你还记得C语言的东西的话，你肯定会说:”这tm不就是C吗”。没错，这tm就是Kotlin版C语言。Old fashion的<code>fopen</code>，<code>stat</code>，<code>fread</code>，当然这一切都无可厚非，毕竟Native的世界和Java的世界本来就大相径庭。我们也可以自己动手封装一个File类出来，我也相信Jetbrains会在某一个版本把这些基本的工具加入到Kotlin Native的标准库中去的。<br>除开C的部分，还是有些东西值得我们关注的，比如刚刚说的<code>nativeHeap</code>，以及一个有趣的方法——<code>toKString()</code>。这个方法真的可以说是Kotlin Native最后的仁慈了。我们知道Kotlin的String和C的const char<em> 是两个完全不同的体系。String类里有记录String长度的部分，好让我们知道String在什么位置结束，但是const char</em> 不同，它依赖结尾处的<code>0x00</code>来判断字符串是否结束。于是这里Kotlin Native很<strong>贴心</strong>的为我们加入了<code>toKString()</code>和<code>String.cstr</code>来保证两者间的转换。</p><h1 id="nativeHeap和memScope？"><a href="#nativeHeap和memScope？" class="headerlink" title="nativeHeap和memScope？"></a>nativeHeap和memScope？</h1><blockquote><p>参考资料 <a href="https://resources.jetbrains.com/storage/products/kotlinconf2018/slides/5_Kotlin-Native%20concurrency%20and%20memory%20model%20(1).pdf" target="_blank" rel="noopener">https://resources.jetbrains.com/storage/products/kotlinconf2018/slides/5_Kotlin-Native%20concurrency%20and%20memory%20model%20(1).pdf</a></p></blockquote><p>有一点是我们必须要知道的，那就是Kotlin Native是有GC的。在Kotlin自己的世界里，GC是隐藏在代码之下的，就像java一样，它们用引用计数法(<em>Simple local reference-counter based algorithm</em>)、”试图删除法”(<em>Cycle collector based on the trial deletion</em>)等算法保证GC的工作。但是由于Kotlin Native提供的东西实在是太少了，我们不得不依赖很多<em>C library</em>,于是手动分配内存就成了不可避免的事情。<br>手动内存管理是场噩梦，这个道理让最顽固的C++也被迫妥协，从析构到现在的智能指针，C++可以说是做了许多让步了。毫无疑问，Kotlin也是懂这个道理的。于是JetBrains推出了memScope这个东西。</p><h2 id="memScope"><a href="#memScope" class="headerlink" title="memScope"></a>memScope</h2><p>memScope的作用是当memScope的作用域结束的时候，自动释放在里面分配的所有内存，以刚才的例子来说</p><pre><code class="Kotlin">val bytes = nativeHeap.allocArray&lt;ByteVar&gt;(size)</code></pre><p>应该写成</p><pre><code class="Kotlin">val text = memScope{    val bytes = nativeHeap.allocArray&lt;ByteVar&gt;(size)    fread(bytes,size.toULong(),size.toULong(),fp)    bytes.toKString()}</code></pre><p>这样当memScope结束的时候，bytes就被自动释放了，而text则是通过<code>toKString()</code>方法实例化的一个String类，可以被KN自己的GC机制回收。所以这段代码不会导致任何内存泄露。除此之外还有很多方法是需要在memScope中才能执行的，比如说<code>CValues&lt;T&gt;.ptr</code>这是用来获取CValues的指针，关于这个稍微说一下我的看法,ptr的getter应该是<em>重新分配</em>了一块内存，然后把CValues中的值<em>复制</em>了进去，因此才需要在memScope中执行，以保证内存不会泄露，不过这又导致了一个新的坑，我在之后会提到。</p><h2 id="nativeHeap"><a href="#nativeHeap" class="headerlink" title="nativeHeap"></a>nativeHeap</h2><p>那为什么我们还需要nativeHeap这样的方式来分配内存呢。还是举个例子吧。</p><pre><code class="Kotlin">fun foo() {    val mgr = nativeHeap.alloc&lt;mg_mgr&gt;().ptr    mg_mgr_init(mgr, null)    while (flag) {        mg_mgr_poll(_mgr, 100)    }    mg_mgr_free(mgr)}</code></pre><p>mg是一个C的网络库，我们启动了一个事件循环来处理各种网络请求。可以看到，这个库自带了一个释放函数<code>mg_mgr_free</code>,被<code>mg_mgr_init</code>初始化过的内存应该由这个库本身来释放。如果我们把代码写成下面这样</p><pre><code class="Kotlin">fun foo() {    memScope{        val mgr = alloc&lt;mg_mgr&gt;().ptr        mg_mgr_init(mgr, null)        while (flag) {            mg_mgr_poll(_mgr, 100)        }        mg_mgr_free(mgr)    }}</code></pre><p>那么在循环终止，程序运行完<code>mg_mgr_free</code>之后很有可能就会因为<code>double free</code>而<em>崩溃</em>。其实我也不是很理解为什么一块内存不能释放两次，或者应该说free为什么不能对同一块内存执行两次，就算已经释放了，给我返回个false也好，何必搞个崩溃呢。总之这也算是刚开始写KN时很容易遇到的一个坑。</p><h2 id="内存管理导致的坑"><a href="#内存管理导致的坑" class="headerlink" title="内存管理导致的坑"></a>内存管理导致的坑</h2><p>在我的工程里，遇到了这么个情况。我有一个系统托盘的功能，里面有一些菜单元素也就是Item，这些Item都是要显示一些字，图标之类的，当然还有回调，每次菜单变化的时候都需要调用一个<code>update</code>函数，这个函数的执行过程实际上就是重新初始化一个整个菜单。<br>最初我的代码是这样的</p><pre><code class="Kotlin">val tray = nativeHeap.alloc&lt;tray&gt;()fun init(){    //设成2是因为tray的C实现需要以空为结尾    val menus = nativeHeap.allocArray&lt;tray_menu&gt;(2)    memScope{        menus[0].text = &quot;设置&quot;.cstr.ptr        //staticCFunction看名字就能知道是为了提供C语言中的&quot;函数指针&quot;        menus[0].cb = staticCFunction { _ -&gt;            //balabalabalabala            tray_update(tray.ptr)        }        tray.menu = menus        tray_init(tray.ptr)    }}</code></pre><p>代码看上去没什么问题，启动的时候也没什么问题，但是当运行<code>menus[0]</code>的<code>callback</code>执行的时候问题就来了。update之后”设置“这两个字变成了乱码，而罪魁祸首就是memScope。memScope在作用域结束的时候释放掉了<code>&quot;设置&quot;.cstr.ptr</code>这个指针(ptr)对应的内存，也就是说在<code>tray_init</code>之后<code>menus[0].text</code>已经是个野指针了。于是当我们执行<code>tray_update</code>的时候，这块内存会是什么样子已经不是我们能够控制的了。于是，我被迫写出了这样的代码</p><pre><code class="Kotlin">val tray = nativeHeap.alloc&lt;tray&gt;()fun init(){    //设成2是因为tray的C实现需要以空为结尾    val menus = nativeHeap.allocArray&lt;tray_menu&gt;(2)    val text = &quot;设置&quot;.cstr    val textPtr = nativeHeap.allocArray&lt;ByteVar&gt;(text.size)    memScope{        //把内存复制到不会被自动释放的地方        memcpy(textPtr,text.ptr,text.size.toULong())    }    menus[0].text = textPtr    menus[0].cb = staticCFunction { _ -&gt;            //balabalabalabala            tray_update(tray.ptr)        }        tray.menu = menus        tray_init(tray.ptr)}</code></pre><p>这只能说是很傻逼了,可能KN提供了一些更加优雅的方式只是我不知道。但总之Kotlin Native的<code>memScope</code>在某些情况下是会与C产生冲突的，而且这种问题往往很隐蔽，这也就是为什么野指针会成为困扰C/C++这么久的问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>OK，去掉代码大概有3000个字了。<br>第一篇就先到此为止，大概写了一下我对Kotlin Native的看法和对它内存模型的认识以及使用中遇到的几个坑。下一篇会应该会写一下Cinterop，和Kotlin Native的多线程模型。KN的多线程对于初学者来说也是个神坑，就没见过这样的线程模型，而且文档也比较含糊，不过毕竟还在频繁更新，很多东西变的太快了，文档也确实比较难写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Wooyme/Wsocks-Naitve-
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://wooyme.github.io/tags/Kotlin/"/>
    
      <category term="Native" scheme="http://wooyme.github.io/tags/Native/"/>
    
      <category term="C" scheme="http://wooyme.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写Ss</title>
    <link href="http://wooyme.github.io/2018/12/16/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Ss/"/>
    <id>http://wooyme.github.io/2018/12/16/自己动手写Ss/</id>
    <published>2018-12-15T16:28:59.000Z</published>
    <updated>2018-12-15T18:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><blockquote><p><a href="https://github.com/Wooyme/Wsocks" target="_blank" rel="noopener">https://github.com/Wooyme/Wsocks</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近VPN不太太平，无论是商业的还是自己租服务器私建的，都或多或少有些遭众。据说是GFW进行了一波升级，但是我个人还是觉得，它只是又更新了一轮黑名单。总之不管怎么样，最近的科学上网是不太稳当了。<br>一周前，我用了一年的服务器遭到了封禁。一时间大有一种大难临头的感觉，再加上各种流言蜚语，于是决定自己来做一个代理工具。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>用过SS的应该都知道SS由两个部分组成——<strong>客户端</strong>与<strong>服务端</strong>。<strong>客户端</strong>往往运行着一个Socks5代理，能够从浏览器之类的程序获取请求，然后<em>加密</em>发送到<strong>服务端</strong>，<strong>服务端</strong>收到请求后，<em>解密</em>再发送给真正的<strong>目标服务器</strong>并监听<strong>目标服务器</strong>的返回，得到返回后再<em>加密</em>发送给<strong>客户端</strong>，<strong>客户端</strong>再<em>解密</em>后发送给浏览器。  </p><blockquote><p>浏览器 –(明文)–&gt; 客户端 –(密文)–&gt; 服务端 –(明文)–&gt; 目标服务器<br>目标服务器 –(明文)–&gt; 服务端 –(密文)–&gt; 客户端 –(明文)–&gt; 浏览器</p></blockquote><p>整体流程其实非常简单，只是因为有加解密的过程，显得有些繁琐。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>要实现这样一个代理，核心是解决客户端与服务端之间的交互。实现这个交互的方式有很多种，无论是直接基于UDP，UTP，TCP这样的底层协议开发，还是使用HTTP，WebSocket这样应用层的协议都是可行的。<strong>这里我们使用WebSoket协议作为客户端与服务端之间的交互协议</strong></p><h2 id="1-Why-websocket"><a href="#1-Why-websocket" class="headerlink" title="1.Why websocket ?"></a>1.Why websocket ?</h2><ul><li>第一，基于WebSocket的开发实在是太简单了。Websocket作为一个被各大浏览器，以及服务端框架支持的协议，其封装实在是太完善了。使用这些封装好的库，我们就不用考虑TCP协议中会遇到的粘包，UDP中的丢包问题。</li><li>第二，Websocket可以把我们的代理程序伪装成一个站点，因为这是网页与后端间常用的协议，已经被许多社交网站，视频网站，页游使用，所以显得更加正常。</li><li>第三，相较于HTTP这样的应用层协议，websocket占用的资源还是要更小一些的，毕竟我们自己用来跑代理的服务器往往配置不会那么高，资源能省则省。</li></ul><h2 id="2-How-to-do"><a href="#2-How-to-do" class="headerlink" title="2.How to do ?"></a>2.How to do ?</h2><p>基于Websocket的开发是非常简单的，当然前提是得有个够给劲的框架。按照我的博客的惯例，这篇文章，不出意外的会使用Vert.x和Kotlin作为技术栈(笑。顺便说一下，在GC，Cache等参数设置得当的情况下，是可以很大程度上降低JVM的内存占用量的。JVM的许多默认设置都是拿内存换CPU，所以会显得java程序很占内存。<br>那么先贴一段Demo</p><pre><code class="Kotlin">class ServerWebSocket:AbstractVerticle() {    private val logger = LoggerFactory.getLogger(ServerWebSocket::class.java)    private lateinit var netClient: NetClient    private lateinit var httpServer:HttpServer    override fun start(startFuture: Future&lt;Void&gt;){        //初始化一个TCP客户端，后面要用        netClient = vertx.createNetClient()        //初始化HTTP服务端        httpServer = vertx.createHttpServer()        //设置websocket处理器,用于处理所有与websocket相关的功能        httpServer.websocketHandler(this::socketHandler)        httpServer.listen(port,it.completer()){            logger.info(&quot;Proxy server listen at $port&quot;)            startFuture.complete()        }    }    private fun socketHandler(sock: ServerWebSocket){        sock.binaryMessageHandler { buffer -&gt;            GlobalScope.launch(vertx.dispatcher()) {                when (buffer.getIntLE(0)) {                    //处理连接请求                    Flag.CONNECT.ordinal -&gt; clientConnectHandler(sock, ClientConnect(buffer))                    //处理数据请求                    Flag.RAW.ordinal -&gt; clientRawHandler(sock, RawData(buffer))                }            }        }        //接受连接，可以在这之前做一些鉴权的工作        sock.accept()    }}</code></pre><p>服务端的整体结构就如Demo所示，在服务端接受了客户端的websocket握手之后，就会处理客户端发送的两种请求。下面是两种请求处理的实现</p><pre><code class="Kotlin">//处理连接请求private suspend fun clientConnectHandler(sock: ServerWebSocket, data:ClientConnect){    try {        //TCP Client尝试连接到目标服务器        val net = netClient.connectAwait(data.port, data.host)        //连接成功则设置handler        net.handler { buffer-&gt;        //把目标服务器返回的数据加密发送给客户端            sock.writeBinaryMessage(RawData.create(data.uuid,buffer).toBuffer())        }.closeHandler {            localMap.remove(data.uuid)        }        localMap[data.uuid] = net    }catch (e:Throwable){      logger.warn(e.message)      //连接失败则告诉客户端连接失败      sock.writeBinaryMessage(Exception.create(data.uuid,e.localizedMessage).toBuffer())      return    }    //告诉客户端连接成功    sock.writeBinaryMessage(ConnectSuccess.create(data.uuid).toBuffer())}//处理数据请求private fun clientRawHandler(sock: ServerWebSocket, data: RawData){    val net = localMap[data.uuid]    //把客户端的数据解密发送目标服务器    net?.write(data.data)?:let{        sock.writeBinaryMessage(Exception.create(data.uuid,&quot;Remote socket has closed&quot;).toBuffer())    }}</code></pre><p>其中uuid是为了保证数据在传输过程中能够找到请求发起者，不然客户端收到了返回的数据，会出现不知道是谁发起的问题。当然这个问题也可以用其他方式实现，理论上说，封装的再完善一点的话，是能够只靠闭包解决。<br>以下是RawData类，展示数据加密过程,加密方式是<code>AES/CBC/PKCS5Padding</code>，javax库中提供的加密方式</p><pre><code class="Kotlin">class RawData(private val buffer:Buffer) {    private val decryptedBuffer = Buffer.buffer(Aes.decrypt(buffer.getBytes(Int.SIZE_BYTES,buffer.length())))    private val uuidLength = decryptedBuffer.getIntLE(0)    val uuid = decryptedBuffer.getString(Int.SIZE_BYTES,Int.SIZE_BYTES+uuidLength)    val data = decryptedBuffer.getBuffer(Int.SIZE_BYTES+uuidLength,decryptedBuffer.length())    fun toBuffer() = buffer    companion object {        fun create(uuid:String,data:Buffer):RawData {        val encryptedBuffer = Aes.encrypt(Buffer.buffer()            .appendIntLE(uuid.length)            .appendString(uuid)            .appendBuffer(data).bytes)        return RawData(Buffer.buffer()            .appendIntLE(Flag.RAW.ordinal)            .appendBytes(encryptedBuffer))        }    }}</code></pre><p>到此，服务端的功能就实现了。接下来就是如何实现客户端</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端与浏览器交互的部分，我们选择Socks5协议，这个Vert.x库不带支持，所以需要自己实现以下。实现代码可以看Wsocks的ClientSocks5类，这里只展示客户端与服务端的交互。</p><pre><code class="Kotlin">//核心部分httpClient.websocket(remotePort,remoteIp,&quot;/proxy&quot;){ webSocket -&gt;      webSocket.binaryMessageHandler {buffer-&gt;        if (buffer.length() &lt; 4) {          return@binaryMessageHandler        }        when (buffer.getIntLE(0)) {          //连接成功          Flag.CONNECT_SUCCESS.ordinal -&gt; wsConnectedHandler(ConnectSuccess(buffer).uuid)          //出现异常          Flag.EXCEPTION.ordinal -&gt; wsExceptionHandler(Exception(buffer))          //目标服务器返回数据          Flag.RAW.ordinal -&gt; wsReceivedRawHandler(RawData(buffer))          else -&gt; logger.warn(buffer.getIntLE(0))        }      }    }</code></pre><pre><code class="Kotlin">//处理器部分private fun wsConnectedHandler(uuid:String){    val netSocket = connectMap[uuid]?:return    netSocket.handler {      //将浏览器的数据，加密发送到服务端      ws.writeBinaryMessage(offset,RawData.create(uuid,it).toBuffer())    }    //告诉浏览器连接成功    val buffer = Buffer.buffer()      .appendByte(0x05.toByte())      .appendByte(0x00.toByte())      .appendByte(0x00.toByte())      .appendByte(0x01.toByte())      .appendBytes(ByteArray(6){0x0})    netSocket.write(buffer)}private fun wsReceivedRawHandler(data: RawData){    val netSocket = connectMap[data.uuid]?:return    bufferSizeHistory+=data.data.length()    //把解密后的数据发送给浏览器    netSocket.write(data.data)}private fun wsExceptionHandler(e:Exception){    //出现异常，断开浏览器本次连接    connectMap.remove(e.uuid)?.close()}</code></pre><p>至此，浏览器和客户端，客户端和服务端，服务端和目标服务器之间的数据交互就完成了。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>由于我只是个普通写后台的，并不是专业的密码学研究者，所以对于加密这块内容，也不敢做过多的分析。但是结合GFW所处的实际情况，我觉得自己还是可以稍微评论一下的。实际上Github上也还有一些类Shadowsocks的产品，比如说<code>Lightsocks</code>，star数也挺高。它们有些产品采用了自己开发的加密算法，而不是<code>Aes</code>，<code>Rc4</code>，之类的主流加密。按照作者的意思是，采用自己开发的加密能够更加有效的方式GFW解密。<br>这么说当然也是有一定道理的，但是实际上这些自研的算法往往比较脆弱，更容易遭到像词频分析之类的方法解密。但是其实我们还要考虑一个问题，GFW只是一个部署在主干网络上的计算机集群，它不是神，它的模型、运算量都是有限的， 每秒都有大量的流量经过它，要通过分析流量<em>解密</em>数据很明显是不可能的事情，就算我们总说Aes128过时了，Aes128有漏洞，但是针对Aes128的攻击依然条件苛刻。<br>在这里还可以举个例子，SSL我们都认为它是安全的，但是针对SSL或者说HTTPS的<em>中间人</em>攻击是存在的，只是这种攻击实现的原理绝对不是分析加密后的数据，而是通过分析<strong>握手环节</strong>的数据拿到秘钥来解密后续的数据。同样的，GFW也是这么做的，而对于这种情况，只要秘钥不出现在流量中，GFW就很难有操作的空间了。<br>还可以再举另一个例子，杀毒软件判断一个程序是否是病毒、木马，靠的是<strong>特征码</strong>和<strong>行为分析</strong>，<strong>特征码</strong>就是病毒为了执行某一系列操作而必定存在的代码，而<strong>行为分析</strong>则是把病毒放在沙箱环境内，观察病毒做了哪些操作。GFW也是如此，在流量中查找特征码比解密流量要容易的多，像Shadowsocks这样的程序产生的流量特征是很明显的，除此之外，GFW还拥有主动探测的能力，在发现特征后，它会尝试构造特殊的报文发送给目标，并根据目标的行为判断是否为Shadowsocks服务端。这种嗅探的成本也是非常低的。 </p><h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><p>就如我在前面写的，使用Websocket这样的协议能够把我们的流量伪装成正常的网站流量。当然这并不完善，因为这样的程序一旦多起来，GFW也一定会开发出针对Websocket的特征分析。这个时候就需要一种更加灵活的方式，比如在数据头部填充，在报文的某几个位置插入字节。这些都可以破坏报文的特征，就像我们给病毒修改入口点、加壳、加花，来起到免杀的效果一样。<br>针对GFW的主动嗅探，则可以考虑动态白名单之类的机制，想要发送请求，就要到另一台服务器上登录，登录过程可以经过国内一台服务器做跳板，这样对于GFW来说，整个过程就是两组不相干的流量。如果要将这样的流量放在一起建立模型的话，也许要到2050年吧。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>国内普遍言论还是把GFW神化了，这东西确实很强，也不知道是哪些研究所在负责维护，但是毕竟算法再强，模型再完美也要受硬件所限。这方面，Google没有解决的问题，中国政府也尚且没有这样的实力。很多时候，解决问题还是不要硬刚，换个角度想一下，可能效果更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Wooyme/Wsocks&quot; target
      
    
    </summary>
    
    
      <category term="Vert.x" scheme="http://wooyme.github.io/tags/Vert-x/"/>
    
      <category term="Kotlin" scheme="http://wooyme.github.io/tags/Kotlin/"/>
    
      <category term="VPN" scheme="http://wooyme.github.io/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置fastcgi-perl</title>
    <link href="http://wooyme.github.io/2018/09/08/Nginx%E9%85%8D%E7%BD%AEfastcgi-perl/"/>
    <id>http://wooyme.github.io/2018/09/08/Nginx配置fastcgi-perl/</id>
    <published>2018-09-08T06:56:59.000Z</published>
    <updated>2018-09-08T07:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>廉价VPS的小内存实在是供不起JVM，所以只好找别的出路了。php呢不是很喜欢，python又不是很想用，于是选了个硬核一点的Perl作为后端语言。反正前后分离，没了渲染压力后端想怎么玩怎么玩。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><pre><code class="Shell">apt-get install nginx libfcgi-perl wget</code></pre><p>改nginx配置</p><pre><code>server {  listen   80;  root   /var/www/example.com;  location / {      index  index.html index.htm index.pl;  }    location ~ \.pl|cgi$ {      try_files $uri =404;      gzip off;      fastcgi_pass  127.0.0.1:8999;      fastcgi_index index.pl;      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;      include fastcgi_params;      }}</code></pre><p>创建目录,给权限</p><pre><code class="Shell">mkdir /var/www/example.comchown -R www-data:www-data /var/www/example.com</code></pre><p>下载配置FastCGI</p><pre><code class="Shell">wget http://nginxlibrary.com/downloads/perl-fcgi/fastcgi-wrapper -O /usr/bin/fastcgi-wrapper.plwget http://nginxlibrary.com/downloads/perl-fcgi/perl-fcgi -O /etc/init.d/perl-fcgichmod +x /usr/bin/fastcgi-wrapper.plchmod +x /etc/init.d/perl-fcgiupdate-rc.d perl-fcgi defaults/usr/lib/insserv/insserv perl-fcgi</code></pre><p>启动!</p><pre><code class="Shell">service nginx startservice perl-fcgi start</code></pre><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a><strong>坑</strong></h2><p>顺利的话，就启动了。不顺利的话，启动perl-fastcgi的时候会失败，报错说<code>this account is currently not available</code>。Google了一圈好像没人在配置cgi的时候遇到这样的问题，比较多的是有些脑洞大开的人想从ssh登录到www-data这个用户上。<br>顺便说一下www-data这个用户，如果看Nginx的进程的话</p><pre><code class="Shell">ps -ef | grep nginx</code></pre><p>会看到nginx的几个worker-process所属的用户都是www-data，这个就是专门给web应用提供的用户。<br>看了一下这些登录不了的解决方案，发现cgi的问题应该也可以用同样的方法解决。</p><p>在<code>/etc/passwd</code>里，我们可以找到www-data的那行，然后就会发现它的结尾是<code>/usr/sbin/nologin</code>，我们要改成<code>/bin/bash</code>。这样这个用户就有运行perl脚本的能力了。重新启动一下服务，就OK了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;廉价VPS的小内存实在是供不起JVM，所以只好找别的出路了。php呢不是很喜欢，python又不是很想用，
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://wooyme.github.io/tags/Nginx/"/>
    
      <category term="perl" scheme="http://wooyme.github.io/tags/perl/"/>
    
      <category term="运维" scheme="http://wooyme.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
